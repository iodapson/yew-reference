<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yew Reference</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">2.</strong> Hello world yew app!</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">3.</strong> Hello world yew app (multi-dir)</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">4.</strong> Log to console (using gloo dependency)</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">5.</strong> Log complex data type, e.g, struct to console (using gloo, serde, serde_json)</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">The Fundamentals</li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">6.</strong> Html-Rust variable templating</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">7.</strong> Fragments (common parent element ancestory)</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">8.</strong> Conditional rendering (if-else, if-let, if-let-else blocks)</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">9.</strong> Looping (for lists)</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Applying Styles</li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">10.</strong> Using crate 'stylist' to style yew apps (ideal for styling fragments and parent elements or components)</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">11.</strong> Inline styling with css! macro</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">12.</strong> External .css stylesheet with Yew</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Parent-Child Components</li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">13.</strong> Embedding a component inside another component</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">14.</strong> Passing properties into an embedded component</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">15.</strong> Defining optional properties for an embedded component</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">16.</strong> Using passed in properties to a child component inside the child component itself</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Components</li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">17.</strong> Creating enum property value(s) inside a component</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">18.</strong> Passing data from child component to parent component</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">19.</strong> Creating form components (including a form assembler)</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">20.</strong> Handling text input in an input component</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">21.</strong> Using Callback for handling (sending-recieving) text input data</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Hook 'use_state'</li><li class="chapter-item expanded "><a href="chapter_21.html"><strong aria-hidden="true">22.</strong> Hook 'use_state'</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_22.html"><strong aria-hidden="true">23.</strong> Buttons and counters for an up to date view</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_23.html"><strong aria-hidden="true">24.</strong> Singular complex struct state versus multiple individual states</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_24.html"><strong aria-hidden="true">25.</strong> Enhanced singular complex struct state versus multiple individual states</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Forms</li><li class="chapter-item expanded "><a href="chapter_25.html"><strong aria-hidden="true">26.</strong> Forms 1 - inputs and buttons with a struct 'use_state'</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_26.html"><strong aria-hidden="true">27.</strong> Forms 2 - submitting form data</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">More Hooks</li><li class="chapter-item expanded "><a href="chapter_27.html"><strong aria-hidden="true">28.</strong> Hook 'use_context' (immutable sharing)</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_28.html"><strong aria-hidden="true">29.</strong> Hook 'use_context' (mutable sharing by both parent and sub-components)</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_29.html"><strong aria-hidden="true">30.</strong> Hook 'use_effect'</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Page Navigation</li><li class="chapter-item expanded "><a href="chapter_30.html"><strong aria-hidden="true">31.</strong> Yew router - 'BrowserRouter'</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_31.html"><strong aria-hidden="true">32.</strong> Link to another component without any page refresh using 'Link'</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_32.html"><strong aria-hidden="true">33.</strong> Hook 'use_history' for programmatic linking between components</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Struct Components</li><li class="chapter-item expanded "><a href="chapter_33.html"><strong aria-hidden="true">34.</strong> Creating a component with a struct</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_34.html"><strong aria-hidden="true">35.</strong> Styling a struct component</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_35.html"><strong aria-hidden="true">36.</strong> Passing properties to struct components</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_36.html"><strong aria-hidden="true">37.</strong> The struct component lifecycle methods</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_37.html"><strong aria-hidden="true">38.</strong> Struct component messages</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Yewdux</li><li class="chapter-item expanded "><a href="chapter_38.html"><strong aria-hidden="true">39.</strong> Yewdux with struct-based components</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_39.html"><strong aria-hidden="true">40.</strong> Yewdux with a collecting-summarizing struct-based component</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_40.html"><strong aria-hidden="true">41.</strong> Yewdux with function component, includes a collecting-summarizing function component as well</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_41.html"><strong aria-hidden="true">42.</strong> Yewdux for persistent storage in functional components</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Yew Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="about"><a class="header" href="#about">About</a></h2>
This is a cook book for Yew. It demonstrates various Yew concepts and actions you will typically perfom using Yew.
<p>Each chapter's code demonstration is a mini standalone Yew project that you run locally on your machine.</p>
<h2 id="conventions"><a class="header" href="#conventions">Conventions</a></h2>
<p style="margin-bottom: 10px;">Pay attention to the comments.</p>
<div style="margin-bottom: 10px;">
<code>//*</code>or<code>// *</code>: Important comments essential to the currently viewed chapter's code demo have this comment.
</div>
<div>
<code>//</code>: Regular comments that are used to annotate what is going on in a given chapter's code demo.
</div>
<h3 id="attributions"><a class="header" href="#attributions">Attributions</a></h3>
<ul>
  <li style="padding-bottom: 4px;"><a href="https://www.youtube.com/watch?v=A0wabjmYRZ0">Introduction to Yew.rs</a>: This documentation project took inspiration from, is based on, and modeled after this wonderful course.</li>
  <li style="padding-top: 4px;"><a href="https://yew.rs">Yew.rs</a>: This is the Yew Official documentation page. References have been made here to keep in sync with the Yew's developmental pace and stay up to date! This is the ultimate sanctuary to meditate on Yew.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-time-reading-this-reference-start-here"><a class="header" href="#first-time-reading-this-reference-start-here">First time reading this reference? Start Here</a></h1>
<h2 id="hello-world-yew-app"><a class="header" href="#hello-world-yew-app">Hello world yew app</a></h2>
<ul>
<li>
<p>First things first, run command;</p>
<p><code>$ rustup target add wasm32-unknown-unknown</code></p>
</li>
<li>
<p>Next;</p>
<p><code>$ cargo install trunk</code></p>
<p>N.B: If you already have trunk (which works like 'create-react-app) installed, the command above to install trunk would be ignored.</p>
</li>
<li>
<p>Inside your cargo.toml file, under <code>[dependencies]</code>, add;</p>
<p><code>yew = &quot;0.19.3&quot;</code></p>
<p>..and hit save.</p>
</li>
<li>
<p>Next up, create an index.html file. A simple bare html boilerplate will do.</p>
</li>
<li>
<p>Now inside <code>main.rs</code> for your binary crate project, use Yew's prelude like so;</p>
<p><code>use yew::prelude::*;</code></p>
<pre>// - Inside main.rs file</pre>
<pre><code class="language-rust">use yew::prelude::*;
fn main() {
  // replace
  // println!(&quot;Hello world!&quot;);
  // ..with
  yew::start_app::&lt; App&gt;(); // to run function component App below
}
// Now turn the function app below into a function component
#[function_component(App)]
fn app() -&gt; Html {
  html! {
    &lt; h1&gt;{&quot;Hello world&quot;}&lt; /h1&gt;
  }
}
</code></pre>
<pre>
// - Inside index.html file in project's root dir
// Initiate html boiler code, probably by using '! + tab' or 'html + tab'
// And that is all you need to do. Change the title tag's value to choose your webpage's title
</pre>
<pre>// Now to run your Yew app, type command<pre>
<code>$ trunk serve</code>


</li>
<li>
<p>Note that you can apply custom styling to your yew app using the html <code>&lt;style&gt;&lt;/style&gt;</code> tag.</p>
</li>
</ul>
<p><strong>If you are using Visual Studio Code and Yew 0.19.3 and your project has issues with cargo and Rust analyzer, then Reload the Window. Check your internet connection too</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world-yew-app-multi-dir"><a class="header" href="#hello-world-yew-app-multi-dir">Hello world yew app (multi-dir)</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre> INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;</pre>
</code></p>
<p><small> See more keys and their definitions at <code>https://doc.rust-lang.org/cargo/reference/manifest.html</code></small></p>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
#[function_component(App)]
pub fn app() -&gt; Html {
  html! {
    &lt;h1&gt;{&quot;Hello World&quot;}&lt;/h1&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;
fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<p>To check this yew app out, open your browser and enter url:</p>
<pre><code>localhost:8080
</code></pre>
<p>This is Yew's default port.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="log-to-the-console"><a class="header" href="#log-to-the-console">Log to the console</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
<p>[dependencies]
yew = &quot;0.19.3&quot;
gloo = &quot;0.6.1&quot;</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use gloo::console::log;

#[function_component(App)]
pub fn app() -&gt; Html {
  // the following variable 'target' can be logged
  let target= &quot;something&quot;;
  log!(&quot;show&quot;, target);
  html! {
    &lt;h1&gt;{&quot;Hello World&quot;}&lt;/h1&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="log-a-complex-data-type-like-a-struct-to-the-console-using-serde"><a class="header" href="#log-a-complex-data-type-like-a-struct-to-the-console-using-serde">Log a complex data type like a struct to the console using serde</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
<span># You need 'gloo', 'serde' and 'serde_json'</span>
gloo = &quot;0.6.1&quot;
serde = &quot;1.0.136&quot;
serde_json = &quot;1.0.79&quot;</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use gloo::console::log;
use yew::prelude::*;
use serde::{Serialize, Deserialize};

// * First make sure struct is serialized using serde by use of #[derive(Serialize)]
// ..optionally also deserialize
#[derive(Serialize, Deserialize)]
struct AStruct {
  first_field: String,
  second_field: String,
}

#[function_component(App)]
pub fn app() -&gt; Html {
  let some_str = &quot;sample&quot;;
  // * AStruct initialization
  let a_struct_var_binding = AStruct {
    first_field: some_str.to_owned(),
    second_field: &quot;another str&quot;.to_owned(),
  };
  // * Time to log target struct 'a_struct_var_binding'
  log!(serde_json::to_string_pretty(&amp;a_struct_var_binding).unwrap());
  html! {
    &lt;h1&gt;{&quot;Hello World&quot;}&lt;/h1&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="html-rust-variable-name-templating"><a class="header" href="#html-rust-variable-name-templating">Html-Rust variable name templating</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[function_component(App)]
pub fn app() -&gt; Html {
  //* Rust variable name
  let some_value = &quot;sample&quot;;
  //* Notice how the variable name 'some_value' is used like a template
  html! {
    &lt;h1 class={some_value}&gt;{&quot;Hello World&quot;}&lt;/h1&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fragments-common-parent-element-ancestory"><a class="header" href="#fragments-common-parent-element-ancestory">Fragments (Common parent element ancestory)</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[function_component(App)]
pub fn app() -&gt; Html {
  //* Yew mandates that you have only one element returned by 'html!' macro
  //* To return multiple elements, feel free to make use of a fragment as done below:
  html! {
    &lt;&gt;
      &lt;h1 class=&quot;class-a&quot;&gt;{&quot;Hello World&quot;}&lt;/h1&gt;
      &lt;strong&gt;{&quot;I'm element number two&quot;}&lt;/strong&gt;
    &lt;/&gt;
  } // N.B: You cannot style fragments
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conditional-rendering-if-blocks"><a class="header" href="#conditional-rendering-if-blocks">Conditional rendering (if-blocks)</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[function_component(App)]
pub fn app() -&gt; Html {
  let some_value = &quot;sample&quot;;
  let option_value = Some(&quot;an option&quot;);

  html! {
    &lt;&gt;

      if some_value == &quot;sample&quot; { //* Here, you can see conditional rendering in action
        &lt;h1 class={some_value}&gt;{&quot;Hello World! I matched 'sample'.&quot;}&lt;/h1&gt;
      } else {
        &lt;h1 class={&quot;invalid&quot;}&gt;{&quot;Hello world! I matched 'an option'.&quot;}&lt;/h1&gt;
      }

      {
        // if-let example below. Please delete me and my block to make this module compile.
      }

      if let Some(val) = option_value {
        &lt;p&gt;{&quot;And variable 'option_value' has value: &quot;}{val}&lt;/p&gt;
      } else {
        &lt;p&gt;{&quot;show no option&quot;}&lt;/p&gt;
      }

    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="looping-for-lists"><a class="header" href="#looping-for-lists">Looping (for lists)</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[function_component(App)]
pub fn app() -&gt; Html {
  //* Here, you can see the vec list that will be iterated
  let the_list: Vec&lt;&amp;str&gt; = vec![&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;, &quot;item4&quot;];
  html! {
    &lt;&gt;
      &lt;ol&gt;
        {
          //* The iteration is below:
          //* ..Note that you can extract the iteration code below into a function which you then simply call.
          //* And please delete me and my block to make this code compile.
        }
        {
          the_list.iter().map( |item| html!{
            &lt;li&gt;{item}&lt;/li&gt;
          }).collect::&lt;Html&gt;()
        }
      &lt;/ol&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-crate-stylist-to-style-yew-apps"><a class="header" href="#using-crate-stylist-to-style-yew-apps">Using crate 'stylist' to style yew apps</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.1&quot; features = [&quot;yew&quot;]}</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
//* use the stylist functions/macros/namespaces required
use stylist::yew::{styled_component};
use stylist::style;

//* To use stylist, you must apply a 'styled_component' rather than a 'function_component'
#[styled_component(App)]
pub fn app() -&gt; Html {

  //* Now make use of the style! macro to create the style.
  //* Note that 'style!' returns a result, so remember to unwrap
  let a_style = style! (
    r#&quot;
      font-size: 24px;
      text-align: center;
      span {
        color: blue;
      }
    &quot;#
  ).unwrap();

  //* Time to use &quot;a_style&quot; created with 'style!'
  //* You'd have to assign &quot;a_style&quot; to your target element's 'class' in order to apply it
  html! {
    &lt;div class={a_style}&gt;
      &lt;p&gt;
        {&quot;Texting with style!&quot;}
      &lt;/p&gt;
      &lt;span&gt;{&quot;cool eh!&quot;}&lt;/span&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="inline-styling-for-yew-apps-using-css-macro-ideal-for-inline-styling-of-individual-elements"><a class="header" href="#inline-styling-for-yew-apps-using-css-macro-ideal-for-inline-styling-of-individual-elements">Inline styling for yew apps (using css! macro) ..ideal for inline styling of individual elements</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.1&quot; features = [&quot;yew&quot;]}</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
//* use the stylist functions/macros/namespaces required
use stylist::yew::{styled_component};

//* To use stylist, you must used a 'styled_component' rather than 'function_component'
#[styled_component(App)]
pub fn app() -&gt; Html {

  //* Notice how css! macro was used to create a value for the class of the target element
  html! {
    &lt;&gt;
      &lt;p class={css!(&quot;color: orange;&quot;)}&gt;
        {&quot;Texting with style!&quot;}
      &lt;/p&gt;
      &lt;span class={css!(&quot;color: gold; text-size: 12px; background-color: black;&quot;)}&gt;
        {&quot;cool eh!&quot;}
      &lt;/span&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="styling-yew-apps-with-an-external-css-stylesheet-with-macro-include_str"><a class="header" href="#styling-yew-apps-with-an-external-css-stylesheet-with-macro-include_str">Styling Yew apps with an external .css stylesheet with macro include_str!()</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.1&quot; features = [&quot;yew&quot;]}
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/main.css'</pre>
<pre><code class="language-css">p {
	background-color: yellowgreen;
	color: beige;
	border: 1px solid pink;
	border-radius: 50px;
	text-align: center;
	font-style: italic;
	font-size: 18px;
	padding: 5px;
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
//* Use the stylist functions/macros/namespaces required
use stylist::yew::{styled_component};
//* ..Note 'Style' instead of 'style' used here
use stylist::Style;

//* Create a variable that holds a reference to the external css stylesheet using 'include_str!'
const EXTERNAL_STYLE: &amp;str = include_str!(&quot;main.css&quot;);

//* To use stylist, you must used a 'styled_component' rather than 'function_component'
#[styled_component(App)]
pub fn app() -&gt; Html {

  //* Apply reference to external css stylesheet as the basis of new style which yew can understand
  let external_style = Style::new(EXTERNAL_STYLE).unwrap(); //* Style::new returns a result

  html! {
    &lt;&gt;
      {
        //* Now you make use of the external style 'external_style' in this case
        // Please delete me and my enclosing block to make this module compile.
      }
      &lt;div class={external_style}&gt;
        &lt;p&gt;
          {&quot;Texting with style!&quot;}
        &lt;/p&gt;
        &lt;span&gt;
          {&quot;External style!&quot;}
        &lt;/span&gt;
      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="embedding-a-component-in-another-component"><a class="header" href="#embedding-a-component-in-another-component">Embedding a component in another component</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.1&quot; features = [&quot;yew&quot;]}
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">//* This is a sub-component inside dir 'src/components/sub_components_a'
use yew::prelude::*;
// Decide whether or not you want a styled component or a function component. I chose function component
#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1() -&gt; Html {
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;Hi! I am from component file 'src::components::sub_components_a::sub_components_a_component_1'&quot;}&lt;/p&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

//* Specify 'components' directory (which is a sibling of 'lib.rs') as a mod, like so;
mod components;

//* ..then use the subcomponent of choice inside sub_components_a directory
use components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

#[function_component(App)]
pub fn app() -&gt; Html {
  html! {
    &lt;&gt;
      &lt;div&gt;
        &lt;p&gt;
          {&quot;I'm a paragraph in component 'App' created in lib.rs.&quot;}
        &lt;/p&gt;
        &lt;span&gt;
          {&quot;I'm a span text in component 'App' too.&quot;}
        &lt;/span&gt;
        {
          //* Time to embed component 'SubComponentsAComponent1' inside this component
          // Please delete me and my enclosing block to make this module compile.
        }
        &lt;SubComponentsAComponent1 /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="passing-properties-to-a-component-which-is-embedded-in-another-component"><a class="header" href="#passing-properties-to-a-component-which-is-embedded-in-another-component">Passing properties to a component which is embedded in another component</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre style="color: orange">INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">// This is a sub-component inside dir 'src/components/level-one-a'
use yew::prelude::*;

//* You need to create a prop struct which would hold/represent the passed in properties
//* You must also derive 'Properties' and 'PartialEq' on the struct, like so;
#[derive(Properties, PartialEq)]
pub struct Prop {
  pub prop_one: String,
}

//* You must pass a reference of the prop struct to your component's function definition
#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;Saying hi from sub-component:  components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1&quot;}&lt;/p&gt;
      &lt;p&gt;{&amp;prop.prop_one}{&quot; received from parent component 'App' created in lib.rs&quot;}&lt;/p&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

// Specify 'components' directory (which is a sibling of 'lib.rs') as a mod, like so;
mod components;

// * ..then use the subcomponent of choice inside components dir
use components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

#[function_component(App)]
pub fn app() -&gt; Html {
  html! {
    &lt;&gt;
      &lt;div&gt;
        &lt;SubComponentsAComponent1 prop_one=&quot;Confirming 'prop_one' value&quot; /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creatingdefining-optional-properties-for-an-embedded-component"><a class="header" href="#creatingdefining-optional-properties-for-an-embedded-component">Creating/defining optional properties for an embedded component</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">// This is a sub-component inside dir 'src/components/sub_components_a'
use yew::prelude::*;

// * You need to create a prop struct which would hold/represent the passed in properties
// * You must also derive 'Properties' and 'PartialEq' on the struct, like so;
#[derive(Properties, PartialEq, Default, Clone)]
pub struct Props {
  pub prop_one: String,
  // * Time to create an optional property
  pub prop_two: Option&lt;String&gt;, // * &quot;prop_two&quot; is optional, thus may not be passed into embedded component &quot;SubComponentsAComponent1&quot;
}

//* You must pass a reference of the Prop struct to your component's function definition
#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(_props: &amp;Props) -&gt; Html {
  // * Please note that in order to access optional field(s) inside Props, you would need to implement Clone on Props itself
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;I am 'components::sub_components_a::sub_components_a_component_1::SubComponentAComponent1'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;I have a require property 'prop_one' (i.e Prop field 'prop_one')&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;And I have an optional prop too called 'prop_two'. See next chapter to see how I can be accessed.&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;You can see how required and non-required/optional Properties fields can be accessed in the following chapter&quot;}&lt;/p&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

// Specify 'components' directory (which is a sibling of 'lib.rs') as a mod, like so;
mod components;

// ..then use the subcomponent of choice inside components dir
use components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

#[function_component(App)]
pub fn app() -&gt; Html {
  html! {
    &lt;&gt;
      &lt;div&gt;
        {
          //* Time to pass property'prop_one' of struct 'Prop' inside SubComponentsAComponent1 into embeded component SubComponentsAComponent1 itself
          // * Please remove this comment block to make this module actually compile
        }
        &lt;SubComponentsAComponent1 prop_one=&quot;String value for SubComponentsAComponent1's 'prop_one'&quot; /&gt; {/*Notice that &quot;prop_two&quot; is not passed any value because doing so is absolutely optional.*/}
      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;
fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-passed-in-properties-to-an-embedded-child-component-inside-the-embedded-child-components-definition-itself"><a class="header" href="#using-passed-in-properties-to-an-embedded-child-component-inside-the-embedded-child-components-definition-itself">Using passed-in properties to an embedded child component inside the embedded child component's definition itself</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">// This is a sub-component inside dir 'src/components/sub_components_a'
use yew::prelude::*;

// * You need to create a prop struct which would hold/represent the passed in properties
// * You must also derive 'Properties' and 'PartialEq' on the struct, like so;
#[derive(Properties, PartialEq, Default, Clone)]
pub struct Props {
  pub prop_one: String,
  // Time to create an optional property
  pub prop_two: Option&lt;String&gt;, // &quot;prop_two&quot; is optional, thus may not be passed into embedded component &quot;SubComponentsAComponent1&quot;
}

//* You must pass a reference of the 'Prop' struct to your component's function definition
#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {
  // * Please note that in order to access optional field(s) inside Props, you would need to implement Clone on Props itself
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;The value of prop_one is: &quot;}{&quot;\&quot;&quot;}{&amp;props.prop_one}{&quot;\&quot;&quot;}&lt;/p&gt;
      if let Some(prop_two_set_value) = &amp;props.clone().prop_two {
        &lt;p&gt;{&quot;The accessed value of optional prop_two is: &quot;}{&quot;\&quot;&quot;}{prop_two_set_value}{&quot;\&quot;&quot;}&lt;/p&gt;
      } else {
        &lt;p&gt;{&quot;The accessed value of optional prop_two is: not set :/&quot;}&lt;/p&gt;
      }
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

// Specify 'components' directory (which is a sibling of 'lib.rs') as a mod, like so;
mod components;

// ..then use the subcomponent of choice inside components dir
use components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

#[function_component(App)]
pub fn app() -&gt; Html {
  html! {
    &lt;&gt;
      &lt;div&gt;
        {
          //* Time to pass property'prop_one' of struct 'Prop' inside SubComponentsAComponent1 into embeded component SubComponentsAComponent1 itself
          // * Please remove this comment block to make this module actually compile
        }
        &lt;SubComponentsAComponent1 prop_one=&quot;String value for SubComponentsAComponent1's 'prop_one'&quot; /&gt; {/*Notice that &quot;prop_two&quot; is not passed any value because doing so is absolutely optional.*/}
      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;
fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="enum-as-a-prop-fields-value-of-a-component-child-component"><a class="header" href="#enum-as-a-prop-fields-value-of-a-component-child-component">Enum as a prop field's value of a component (child component)</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">// This is a sub-component inside dir 'src/components/sub_components_a'
use yew::prelude::*;
use stylist::yew::{styled_componnent};
use stylist::style;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
  //* Here we use an enum &quot;Level&quot; to create a super property
  pub prop_three: Level,
}

//* You must define the enum used to create a super property using 'derive(PartialEq)', like so;
#[allow(unused)]
#[derive(PartialEq)]
pub enum Level {
  Standard,
  Pro,
  Premium,
  Gold,
}

//* To work with an enum-powered super property, you need to be able to make transformations on it based on its variants
//* ..to do this, you need to impl the enum, e.g;
impl Level {
  pub fn assign_level(&amp;self) -&gt; String {
    match self {
      Level::Standard =&gt; &quot;standard&quot;.to_owned(),
      Level::Pro =&gt; &quot;pro&quot;.to_owned(),
      Level::Premium =&gt; &quot;premium&quot;.to_owned(),
      Level::Gold =&gt; &quot;gold&quot;.to_owned(),
    }
  }
}

#[styled_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Props) -&gt; Html {
  //* Enum super property &quot;Level&quot; will be used to assign badge
  let badge = style!(
    r#&quot;
      .standard {
        color: orange;
      }
      .pro {
        color: green;
      }
      .premium {
        color: blue;
      }
      .gold {
        color: gold;
      }
    &quot;#
  ).unwrap(); // end of 'style!'

  //* Make use of &quot;badge&quot; (style) to be able to assign level as class to nested elements/components
  html! {
    &lt;div class={badge}&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_owned()}&lt;/p&gt;
      &lt;p&gt;{&quot;- '&quot;} {&amp;prop.prop_one.to_owned()} {&quot;'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;AND enum; &quot;}&lt;/p&gt;
      {
        //* Time to assign a level class. Please remember to delete this comment block-scope
      }
      &lt;span class={&amp;prop.prop_three.assign_level()}&gt;{&quot;- &quot;}{&amp;prop.prop_three.assign_level()} {&quot; level&quot;}&lt;/span&gt;

    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

mod components;

//* When using a sub-component with an an enum powered (super) property, you must also use the 'enum' itself
//* ..for example, &quot;SubComponentsAComponent1&quot; utilizes enum &quot;Level&quot; (as a super property)
//* ..therefore, it (&quot;Level&quot;) must be used too, like so;
use components::sub_components_a::sub_components_a_component_1::{SubComponentsAComponent1, Level}; // Note the presence of &quot;Level&quot;

#[function_component(App)]
pub fn app() -&gt; Html {

  html! {
    &lt;&gt;
      &lt;div&gt;
        {
          //* Time to pass enum-powered super property'prop_three' of type enum &quot;Level&quot; to SubComponentsAComponent1 into embeded component SubComponentsAComponent1 which is embedded herein
        }
        &lt;SubComponentsAComponent1
          prop_one=&quot;Confirming prop one value&quot;
          prop_three={Level::Pro}
        /&gt; {/*Notice that &quot;prop_two&quot; is not passed any value because doing so is absolutely optional*/}
      &lt;/div&gt;
    &lt;/&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="passing-data-from-a-child-embedded-component-to-its-parent-component-via-callbacks"><a class="header" href="#passing-data-from-a-child-embedded-component-to-its-parent-component-via-callbacks">Passing data from a child (embedded) component to its parent component via callbacks</a></h2>
<p>N.B: There is struct 'Callback' available to you inside yew's prelude which allows you to pass data up from a child component to a parent element.</p>
<p>N.B: You create a callback by setting a property to be a type Callback<T>, and then calling '.emit' on it. Read on for more details.</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
gloo = &quot;0.6.1&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

// * The callback's to-be-sent data must be present inside the prop object (ie, struct) for the child element
#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
  // * Here we are defining the to-be-sent data for our callback
  pub to_be_sent_data: Callback&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Props) -&gt; Html {

  // * Time to send 'to_be_sent_data' up from this component
  // * ..into whatever component it is being embedded in
  // * ..as a child component
  prop.to_be_sent_data.emit(
    &quot;' Sent as callback data from child component 'SubComponentsAComponent1' to parent component 'App' '&quot;.to_owned(),
  );

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_owned()}&lt;/p&gt;
      &lt;p&gt;{&quot;Please open your Dev Tools to see the logged callback data.&quot;}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use gloo::console::log;
use components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

mod components;

#[function_component(App)]
pub fn app() -&gt; Html {

  // * Create a callback (action) using 'Callback::from' available in yew's prelude
  let callback_receipient_action = Callback::from (
    |received_from_child_component: String| {
      //* Perform some action with data received from child component
      // ..I have decided to simply log it
      log!(&quot;Here is what was &quot;, received_from_child_component)
    }
  );

  // * You also need to assign the callback action of the parent element
  // * ..to the callback property of the child component emitting
  // * ..data to the parent component.
  // * Basically, the parent components needs to acknowledge the child component's callback like so;
  html! {
    &lt;&gt;
      &lt;div&gt;
        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; to_be_sent_data={callback_receipient_action} /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="form-and-yew"><a class="header" href="#form-and-yew">Form and Yew</a></h2>
<p>Note that this kind of bare form setup does not submit the form when a button (e.g. 'submit' button) is clicked.
However, it does cause the page to reload. Bare this in mind.</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
     |-form_components
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembler_component.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/main.css'</pre>
<pre><code class="language-css">p {
	background-color: yellowgreen;
	color: beige;
	border: 1px solid pink;
	border-radius: 50px;
	text-align: center;
	font-style: italic;
	font-size: 18px;
	padding: 5px;
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components; // * Take note of this
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs</pre>
<pre><code class="language-rust">// * Take note of these:
pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;props.prop_one.to_owned()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">//* Create input component code
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one: String,
}

#[function_component(FormInputComponent)]
pub fn form_input_component(props: &amp;Props) -&gt; Html {
  html! {
    {
      // * Notice how you had to clone the property &quot;input_one&quot; in order
      //* ..to assign it as the value to html element 'input' 's attribute
      // * ..'name' 's value
      // * Also, remember to clean up this comment block so the code can compile locally on your machine
    }
    &lt;input type=&quot;text&quot; name={props.input_one.clone()} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">// * Create button component code
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
pub fn form_button_component(props: &amp;Props) -&gt; Html {
  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">// * Here we create a component to assemble form component pieces

use yew::prelude::*;
// * Use &quot;form_input_component&quot; and &quot;form_button_component&quot;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub button_name: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {
  html! {
    &lt;form&gt;
      &lt;FormInputComponent input_one={props.input_one_value.clone()} /&gt;
      &lt;FormButtonComponent button_one={props.button_name.clone()} /&gt;
    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
// Use the stylist functions/macros/namespaces required
use stylist::yew::styled_component;
use stylist::Style;
use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;
// * Use &quot;form_assembler_component&quot;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;

mod components;

const EXTERNAL_STYLE: &amp;str = include_str!(&quot;main.css&quot;);

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap(); // Style::new returns a result

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;
        &lt;p&gt;
          {&quot;Forms Demo!&quot;}
        &lt;/p&gt;
        &lt;span&gt;
          {&quot;...with a little bit of style ^_^&quot;}
        &lt;/span&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;
        {
          //* Time to use FormAssembler
          //* Again, please remember to remove this comment block.
        }
        &lt;FormAssemblerComponent input_one_value=&quot;Input 1&quot; button_name=&quot;Button 1&quot; /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="handling-form-input-text-input-in-a-form"><a class="header" href="#handling-form-input-text-input-in-a-form">Handling form input (text input in a form)</a></h2>
<p>See how to log out every text received from an input component.</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
     |-form_components
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembler_component.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]} 
// * You must use dependencies 'wasm-bindgen', 'web-sys' and even 'gloo' since you want to do some logging
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/main.css'</pre>
<pre><code class="language-css">p {
	background-color: yellowgreen;
	color: beige;
	border: 1px solid pink;
	border-radius: 50px;
	text-align: center;
	font-style: italic;
	font-size: 18px;
	padding: 5px;
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;props.prop_one.to_owned()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component.rs'</pre>
<pre><code class="language-rust">// * This is where we need to handle the text input,
// * ..inside the target input component itself
use yew::prelude::*;
// * use 'wasm_bindgen::JsCast', and 'web_sys::HtmlInputElement'
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one: String,
}

#[function_component(FormInputComponent)]
pub fn form_input_component(props: &amp;Props) -&gt; Html {

  // * Create an action callback which decide what should happen to
  // * ..or with the text event
  let call_to_action = Callback::from(

    | input_event: Event | {
      let input_event_target = input_event.target().unwrap();
      // * Here, feature 'HtmlInputElement' is used
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      // * Simply log &quot;current_input_text&quot; for now..
      log!(current_input_text.value());
    }

  );

  html! {
    {
      // * Notice how you had to clone the property &quot;input_one&quot; in order
      // * ..to assign it as the value to html element 'input' 's attribute
      // * ..'name' 's value
    }
    &lt;input type=&quot;text&quot; name={props.input_one.clone()} onchange={call_to_action} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
pub fn form_button_component(props: &amp;Props) -&gt; Html {
  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

#[derive(Properties, PartialEq, Clone)]
pub struct Props {
  pub input_one_value: String,
  pub button_name: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {
  html! {
    &lt;&gt;
      &lt;FormInputComponent input_one={props.input_one_value.clone()} /&gt;
      &lt;FormButtonComponent button_one={props.button_name.clone()} /&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::{yew::styled_component, Style};
use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;

mod components;

const EXTERNAL_STYLE: &amp;str = include_str!(&quot;main.css&quot;);

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;Another Form Demo!&quot;}
        &lt;/p&gt;
        &lt;span&gt;
          {&quot;...it is a boring style though. &quot;}
        &lt;/span&gt;
        &lt;b&gt;
          {&quot;Please note that the html 'form' element is anywhere in this demo.&quot;}
        &lt;/b&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;
        &lt;FormAssemblerComponent input_one_value=&quot;Input 1&quot; button_name=&quot;Button 1&quot; /&gt;

        &lt;b&gt;{&quot;Check the input you have just entered printed out on the console.&quot;}&lt;/b&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-callbacks-for-handling-form-input-text-input-in-a-form"><a class="header" href="#using-callbacks-for-handling-form-input-text-input-in-a-form">Using callbacks for handling form input (text input in a form)</a></h2>
<p>You will be able to access data from a child component inside a parent element using Callback.</p>
<p>Yew (project) folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
     |-form_components
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembly_component.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]} 
//* You must use dependencies 'wasm-bindgen', 'web-sys' and even 'gloo' since you want to do some logging
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] } // * Note this important feature.
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/main.css'</pre>
<pre><code class="language-css">p {
	background-color: yellowgreen;
	color: beige;
	border: 1px solid pink;
	border-radius: 50px;
	text-align: center;
	font-style: italic;
	font-size: 18px;
	padding: 5px;
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_assembler_component;
pub mod form_button_component;
pub mod form_input_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;props.prop_one.to_owned()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">// This is where we need to handle the text input,
// ..inside the target input component itself
use yew::prelude::*;
// use 'wasm_bindgen::JsCast', and 'web_sys::HtmlInputElement'
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one: String,
  // * Add a callback property to send up-down
  pub callback_data: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
pub fn form_input_component(props: &amp;Props) -&gt; Html {

  // * First create the clone of the &quot;callback_data&quot; property. It is just good practice since it'll be moved
  let callback_data_clone = props.callback_data.clone();

  // First, create a callback action to decide what happens to
  // ..or with the text event
  // * Important Diff:
  // * You need to move &quot;current_input_text.value()&quot; inside &quot;handle_callback_data&quot; Callback function's closure below
  // * ...out of the closure itself, using a clone of callback property &quot;callback_data&quot;
  let handle_callback_data = Callback::from(

    move | input_event: Event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();

      // log!(current_input_text.value()); // * Logging action moved to'FormAssemblerComponent'.
      // ...Check componnet 'FormAssemblerComponents' &quot;callback_data_recieved&quot; where the logging takes place.

      // * Second, emit (move out) &quot;current_input_text.value()&quot; by calling Callback &quot;handle_call_to_action_clone&quot;
      // * ..and then passing in &quot;current_input_text.value()&quot; to it, like this;
      callback_data_clone.emit(current_input_text.value());

      //* Hopefully, you can now see why the 'move' keyword was neccessary;
      //* ..because a value; &quot;current_input_text&quot; was moved out of
      //* ..the closure here in.
    }

  ); // end of &quot;handle_callback_data&quot;

  html! {
    &lt;input type=&quot;text&quot; name={props.input_one.clone()} onchange={handle_callback_data} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
pub fn form_button_component(props: &amp;Props) -&gt; Html {
  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;
//* use gloo so you can log whatever property you receive from a child component, e.g. &quot;FormInputComponent&quot;
use gloo::console::log;

#[derive(Properties, PartialEq, Clone)]
pub struct Props {
  pub input_one_value: String,
  pub button_name: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {
  //* Create a callback that will respond to data received from another component's callback property
  let callback_data_received = Callback::from(
    |received_input| {
      //* Log recieved callback action
      log!(&quot;I received input &quot;, received_input, &quot; from my child component, an input component&quot;);
    }
  );
  //* Now you must pass the callback_receipient herein above to the
  //* ..callback property for the child component &quot;FormInputComponent&quot; that requires it.
  html! {
    &lt;&gt;
      &lt;FormInputComponent input_one={props.input_one_value.clone()} callback_data={callback_data_received} /&gt;
      &lt;FormButtonComponent button_one={props.button_name.clone()} /&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::{yew::styled_component, Style};
use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;

mod components;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;Yet Another Form Demo!&quot;}
        &lt;/p&gt;
        &lt;span&gt;
          {&quot;...with some style&quot;}
        &lt;/span&gt;
        &lt;b&gt;
          {&quot;Please note that the html element 'form' is not used anywhere in this demo.&quot;}
        &lt;/b&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;
        &lt;FormAssemblerComponent input_one=&quot;Input 1&quot; button_one=&quot;Button 1&quot; /&gt;

        &lt;b&gt;{&quot;Check the input you have just entered printed out on the browser console&quot;}&lt;/b&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hook---use_state"><a class="header" href="#hook---use_state">Hook - 'use_state'</a></h2>
<p>Using 'use_state' to update screen to show form input (text input in a form).</p>
<p>You will be able to update your view based on the user's input (which in this case is a text input).</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
     |-form_components
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembly_component.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]} 
// * You must use dependencies 'wasm-bindgen', 'web-sys' and even 'gloo' since you want to do some logging
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] } // * Note this important feature.
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_assembler_component;
pub mod form_button_component;
pub mod form_input_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;props.prop_one.to_owned()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one: String,
  // Add a callback property to send up-down
  //* This Callback property will be used to power a state called &quot;sample_state&quot; inside 'form_assembler'; a parent component
  pub callback_data: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
pub fn form_input_component(props: &amp;Props) -&gt; Html {

  let callback_data_clone = props.callback_data.clone();

  let handle_callback_data = Callback::from(

    move | input_event: Event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();

      callback_data_clone.emit(current_input_text.value());

    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input_one.clone()} onchange={handle_callback_data} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {
  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component.rs'</pre>
<pre><code class="language-rust">// * Here, a use_state is used. Take note.
use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

use gloo::console::log;

#[derive(Properties, PartialEq, Clone)]
pub struct Props {
  pub input_one_value: String,
  pub button_name: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {
  //* Create a state using 'use_state' to monitor child properties or maintain your view to correspond to certain changes
  let sample_state = use_state( || &quot;Initial state&quot;.to_owned()); //* You have to apply 'to_owned()' to the &amp;str as done herein

  //* Clone your created state. It's just good practice.
  let sample_state_clone = sample_state.clone();

  // Create a callback that will respond to data received from another component's callback property
  //* This time you have apply 'move' since you will be moving out an internal variable &quot;received_input&quot; to an outer one &quot;sample_state_clone&quot; via method 'set()'
  let callback_data_received = Callback::from(
    move |received_input: String| {
      //* Now set your cloned state to its new value
      sample_state_clone.set((&amp;*received_input).to_string()); //* Note the '&amp;*' You have to dereference and then reference the 'str' into &amp;str. That is what the '&amp;*' part does.
      log!(
        &quot;I received_input &quot;,
        received_input,
        &quot;from my child component - an input component. I am using hook 'use_state' by the way.&quot;
      )
    }
  );

  html! {
    &lt;form&gt;
      &lt;FormInputComponent input_one={props.input_one_value.clone()} callback_data={callback_data_received} /&gt;
      &lt;FormButtonComponent button_one={props.button_name.clone()} /&gt;
    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::{yew::styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;

mod components;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;Another Form Demo with state!&quot;}
        &lt;/p&gt;

        &lt;b&gt;
          {&quot;Please note that the html 'form' element is not used anywhere in this demo.&quot;}
        &lt;/b&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;
        &lt;FormAssemblerComponent input_one=&quot;Input 1&quot; button_one=&quot;Button 1&quot; /&gt;

        &lt;b&gt;{&quot;Check the input you have just entered printed out on the console.&quot;}&lt;/b&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;//* You could also specify; use crate::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hook---use_state-multiple-states-think-buttons-and-counters"><a class="header" href="#hook---use_state-multiple-states-think-buttons-and-counters">Hook - 'use_state' (multiple states, think buttons and counters)</a></h2>
<p>Using 'use_state' to update screen to show how many times a particular button was clicked.</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
     |-form_components
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembly_component.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] } // * Note this important feature.
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs</pre>
<pre><code class="language-rust">pub mod form_assembler_component;
pub mod form_button_component;
pub mod form_input_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;props.prop_one.to_owned()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one: String,
  pub callback_data: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let callback_data_clone = props.callback_data.clone();

  let handle_callback_data = Callback::from(

    move | input_event: Event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();

      callback_data_clone.emit(current_input_text.value());

    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input_one.clone()} onchange={handle_callback_data} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
  //* Create a Callback property to power click counts
  pub click_count: Callback&lt;()&gt;,
}

#[function_component(FormButtonComponent)]
pub fn form_button_component(props: &amp;Props) -&gt; Html {

  //* Clone &quot;click_count&quot; callback property. It's just good practice to clone a Callback property
  let click_count_clone = props.click_count.clone();

  //* Take note of &quot;counter_action&quot;
  let counter_action = Callback::from(
    move |_| {
      click_count_clone.emit(()); //* 'emit(())' because &quot;click_count&quot; is a Callback&lt;()&gt;
    }
  );
  html! {
    {
      //* In order to perform count when clicked, you need to assign a Callback::from to the
      //* ..button's 'onclick' attribute
      // * Please remember to clear this particualr comment code block
    }
    &lt;button onclick={counter_action}&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_button_component::FormButtonComponent;
use crate::components::form_components::form_input_component::FormInputComponent;

#[derive(Properties, PartialEq, Clone)]
pub struct Props {
  pub input_one_value: String,
  pub button_name: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler_component(props: &amp;Props) -&gt; Html {

  let sample_state = use_state( || &quot;Initial state&quot;.to_owned()); // You have to apply 'to_owned()' to the &amp;str as done herein
  let sample_state_clone = sample_state.clone();

  //* Create a use_state to monitor and change counter for each time &quot;FormButtonComponent&quot; is clicked
  let form_button_click_count = use_state ( || 0_u32);
  //* Clone the use_state &quot;form_button_click_count&quot; created above
  let form_button_click_count_clone = form_button_click_count.clone();

  // Create a callback that will respond to (input) data received from another component's callback property
  let callback_receipient = Callback::from(
    move |received_input: String| {
      // Now set your cloned state to its new value
      sample_state_clone.set((&amp;*received_input).to_string());
    }
  );

  //* Time to create a callback with 'Callback::from' for receiving the counter of/from the &quot;FormButtonComponent&quot; defined earlier
  //* Note that since this Callback::from does not need any event
  //* ..from its child component, its closure argument
  //* ..uses a '_' to ignore args
  let click_count_receipient = Callback::from(
    move |_| {

      //* In order to change the use_state &quot;form_button_click_count_clone&quot; as &quot;FormButtonComponent&quot; is being clicked,
      //* ..you need to call 'set' on it, see below;
      let click_count = *form_button_click_count_clone;
      form_button_click_count_clone.set(click_count + 1);
    }
  );

  //* Use &lt;div&gt;&lt;/div&gt; instead of &lt;form&gt;&lt;/form&gt; for now
  //* ..because using &lt;form&gt;&lt;/form&gt; as it is right now would lead to an endless recursive re-render of the screen
  html! {
    &lt;div&gt;
      &lt;FormInputComponent input_one={props.input_one_value.clone()} callback_data={callback_receipient} /&gt;
      {
        //* Now you need to pass in your Callback::from to your child component's Callback property &quot;click_count&quot;
        // * Please remember to remove this code comment block to make this module run
      }
      &lt;FormButtonComponent button_one={props.button_name.clone()} click_count={click_count_receipient}/&gt;
      {
        //* A simply display of the count for &quot;FormButtonComponent&quot; clicks
        //* Also remember to derefence the use_state &quot;form_button_count&quot; or &quot;form_button_count_clone&quot;
        // * Please remember to clear this code comment block too.
      }
      &lt;p&gt;{&quot;FormButtonComponent's click count is at: &quot;}{*form_button_click_count}&lt;/p&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::{yew::styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;

mod components;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;Another Form Demo with a click counter!&quot;}
        &lt;/p&gt;
        &lt;b&gt;
          {&quot;Please note that the html 'form' element is not used anywhere in this demo&quot;}
        &lt;/b&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;
        &lt;FormAssemblerComponent input_one=&quot;Input 1&quot; button_one=&quot;Button 1&quot; /&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hook---use_state-singular-complex-struct-state-instead-of-multiple-states-think-buttons-and-counters"><a class="header" href="#hook---use_state-singular-complex-struct-state-instead-of-multiple-states-think-buttons-and-counters">Hook - 'use_state' (singular complex struct state instead of multiple states, think buttons and counters)</a></h2>
<p>Using 'use_state' to update screen to show how many times a particular button was clicked.</p>
<p>Please note that the code in this chapter when run leads to nothing particularly very interesting. To see a complex state struct in action (via a click counter demo) proceed to the chapter with the title - Forms 1 - inputs and buttons with a struct 'use_state'.</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
     |-form_components
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembly_component.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] } // * Note this important feature.
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;props.prop_one.to_owned()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one: String,
  pub callback_data: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let callback_data_clone = props.callback_data.clone();

  let handle_callback_data = Callback::from(

    move | input_event: Event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();

      callback_data_clone.emit(current_input_text.value());

    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input_one.clone()} onchange={handle_callback_data} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
  // Create a Callback property to power click counts
  pub click_count: Callback&lt;()&gt;,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  let click_count_clone = props.click_count.clone();

  // Take note of &quot;counter_action&quot;
  let counter_action = Callback::from(
    move |_| {
      conter_action_clone.emit(());
    }
  );
  html! {
    {
      //* In order to perform count when clicked, you need to assign a Callback::from to the
      //* ..button's 'onclick' attribute
      // * Please remember to delete this code comment block to make this module compile
    }
    &lt;button onclick={counter_action}&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

use std::ops::Deref;

#[derive(Properties, PartialEq, Clone)]
pub struct Props {
  pub input_one_value: String,
  pub button_name: String,
}

//* Notice the differnce between complex state management using a struct (with state data as properties) as a state itself
//* ..versus using the 'use_state()' function everywhere, everytime for each state data

//* First create a data struct to manage your states
//* Note, you have to derive 'Clone' and 'Default' on the struct:
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: u32,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  //* You would have to create a 'use_state' and pass in your &quot;StateData&quot; struct as its state.
  let states_data_as_state = use_state( || StatesData::default() ); //* This is where implementing 'Default' proves useful

  let sample_state = use_state( || &quot;Initial state&quot;.to_owned()); // You have to apply 'to_owned()' to the &amp;str as done herein
  let sample_state_clone = sample_state.clone();

  // Create a use_state to monitor and change counter for each time &quot;FormButtonComponent&quot; is clicked
  let form_button_click_count = use_state ( || 0_u32);
  // Clone the use_state &quot;form_button_click&quot; created above
  let form_button_click_count_clone = form_button_click_count.clone();

  // Create a callback that will respond to (input) data received from another component's callback property
  let callback_receipient = Callback::from(
    move |received_input: String| {
      // Now set your cloned state to its new value
      sample_state_clone.set((&amp;*received_input).to_string());
    }
  );

  //* &quot;StatesData&quot;: Time to create a 'Callback::from' for the &quot;StatesData&quot; struct.
  //* ..but before doing that, first clone the state for it
  //* Here, we'll be updating the view based on input data
  let states_data_as_state_clone = states_data_as_state.clone();

  //* Callback::from() for states_data_as_state_clone's &quot;state_one&quot; property
  let _states_data_as_state_clone_callback_receipient = Callback::from(
    move |received_state_one| {
      //* deref &quot;states_data_as_state_clone&quot;, and clone it again :/ lol
      let mut states_data = states_data_as_state_clone.deref().clone();
      //* Now set states_data's &quot;state_one&quot; to &quot;received_state_one&quot;
      states_data.state_one = received_state_one;
      //* Remember to set new &quot;StatesData&quot; struct clone changes as new state, like so;
      states_data_as_state_clone.set(states_data);
    }
  );

  // Time to create a 'Callback::from' for receiving the counter of/from the &quot;FormButtonComponent&quot; defined up above
  // Note that since this Callback::from does not need any event
  // ..from its child component, its closure arg
  // ..uses a '_' to ignore args
  let click_count_receipient = Callback::from(move |_| {

      // In order to change the use_state &quot;form_button_click_count_clone&quot; as &quot;FormButtonComponent&quot; is being clicked,
      // ..you need to call 'set' on it, see below;
      let click_count = *form_button_click_count_clone;
      form_button_click_count_clone.set(click_count + 1);
    }
  );

  // &quot;StatesData&quot;: Time again to create a 'Callback::from' for the &quot;StatesData&quot; struct.
  // ..but before doing that, first clone the state for it
  // Here, we'll be updating the view based on a button's click count
  let states_data_as_state_clone = states_data_as_state.clone();

  //* Callback::from() for states_data_as_state_clone's &quot;state_two&quot; property
  let _states_data_as_state_clone_callback_receipient = Callback::from(
    //* This time we ignore closure arguments for 'Callback::from since we are not expecting nor working with any from its child component
    move |_: StatesData| {
      //* deref &quot;states_data_as_state_clone&quot;, and clone it again
      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two += 1;
      //* Remember to set new &quot;StatesData&quot; struct clone changes as new state, like so;
      states_data_as_state_clone.set(states_data);
    }
  );

  // Use &lt;div&gt;&lt;/div&gt; instead of &lt;form&gt;&lt;/form&gt; for now
  // ..because using &lt;form&gt;&lt;/form&gt; as it is right now would lead to an endless recursive re-render of the screen
  html! {
    &lt;div&gt;
      &lt;FormInputComponent input_one={props.input_one_value.clone()} callback_data={callback_receipient} /&gt;
      {
        // Now you need to pass in your Callback::from to your child component's Callback property &quot;click_count&quot;
      }
      &lt;FormButtonComponent button_one={props.button_name.clone()} click_count={click_count_receipient}/&gt;

      {
        //* Time to ouput our complex state struct's properties (which inversely are themselves now states). Remember nothing noteful happens yet.
      }
      &lt;p&gt;{&quot;State 1 is: &quot;}{&amp;states_data_as_state.state_one}&lt;/p&gt;
      &lt;p&gt;{&quot;State 2 has &quot;}{&amp;states_data_as_state.state_two}{ &quot;clicks!&quot;}&lt;/p&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;

mod components;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;Texting with style!&quot;}
        &lt;/p&gt;
        &lt;span&gt;
          {&quot;cool eh!&quot;}
        &lt;/span&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;
        &lt;FormAssemblerComponent input_one=&quot;Input 1&quot; button_one=&quot;Button 1&quot; /&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hook---use_state-improved-singular-complex-struct-state-instead-of-multiple-states-think-buttons-and-counters"><a class="header" href="#hook---use_state-improved-singular-complex-struct-state-instead-of-multiple-states-think-buttons-and-counters">Hook - 'use_state' (Improved singular complex struct state instead of multiple states, think buttons and counters)</a></h2>
<p>Using 'use_state' to update screen to show how many times a particular button was clicked.</p>
<p>Here, the struct state would be set using destructuring.
I don't seem to like the enhanced version due to (possible?) matching name requirements for destructured field variable names</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] } # //* Note this important feature.
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;props.prop_one.to_owned()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one: String,
  pub string_data_callback: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
pub fn form_input_component(props: &amp;Props) -&gt; Html {

  let string_data_callback_clone = props.string_data_callback.clone();

  let emit_string_data_callback = Callback::from(

    move | input_event: Event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();

      string_data_callback_clone.emit(current_input_text.value());

    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input_one.clone()} onchange={emit_string_data_callback} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
  // Create a Callback property to power click counts
  pub click_count: Callback&lt;()&gt;,
}

#[function_component(FormButtonComponent)]
pub fn form_button_component(props: &amp;Props) -&gt; Html {

  // Clone &quot;click_count&quot; callback property. It's just good practice
  let click_count_clone = props.click_count.clone();

  // Take note of &quot;counter_action&quot;
  let counter_action = Callback::from(
    move |_| {
      click_count_clone.emit(()); //* 'emit(())' because &quot;click_count&quot; is a Callback&lt;()&gt;
    }
  );
  html! {
    {
      // * In order to perform count when clicked, you need to assign a Callback::from to the
      // * ..button's 'onclick' attribute
      // * Remember to remove this comment block to make the project compile and run.
    }
    &lt;button onclick={counter_action}&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

//use gloo::console::log;
use std::ops::Deref;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub button_name: String,
}

//* Notice the differnce between complex state management using a struct (with state data as properties) as a state itself
//* ..versus using the 'use_state()' function everywhere, everytime for each state data

//* First create a data struct to manage your states
//* Note, you have to derive 'Clone' and 'Default' on the struct:
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: u32,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  // You would have to create a 'use_state' and pass in your &quot;StateData&quot; struct as its state.
  let states_data_as_state = use_state( || StatesData::default() ); //* This is where implementing 'Default' proves useful

  let sample_state = use_state( || &quot;Initial state&quot;.to_owned() ); // You have to apply 'to_owned()' to the &amp;str as done herein
  let sample_state_clone = sample_state.clone();

  // Create a use_state to monitor and change counter for each time &quot;FormButtonComponent&quot; is clicked
  let form_button_click_count = use_state ( || 0_u32);
  // Clone the use_state &quot;form_button_click&quot; created above
  let form_button_click_count_clone = form_button_click_count.clone();

  // Create a callback that will respond to (input) data received from another component's callback property
  let callback_receipient = Callback::from(
    move |received_input: String| {
      // Now set your cloned state to its new value
      sample_state_clone.set((&amp;*received_input).to_string());
    }
  );

  // &quot;StatesData&quot;: Time to create a 'Callback::from' for the &quot;StatesData&quot; struct.
  // ..but before doing that, first clone the state for it
  // Here, we'll be updating the view based on input data
  let states_data_as_state_clone = states_data_as_state.clone();

  /* Sample to be enhanced:
  // Callback::from() for states_data_as_state_clone's &quot;state_one&quot; property
  let _states_data_as_state_clone_input_callback_receipient = Callback::from(
    move |received_state_one| {
      // deref &quot;states_data_as_state_clone&quot;, and clone it again
      let mut states_data = states_data_as_state_clone.deref().clone();
      // Now set states_data's &quot;state_one&quot; to &quot;received_state_one&quot;
      states_data.state_one = received_state_one;
      // Remember to set new &quot;StatesData&quot; struct clone changes as new state, like so;
      states_data_as_state_clone.set(states_data);
    }
  );
  */
  //* Here is the enhancement
  let _states_data_as_state_clone_input_callback_receipient = Callback::from(
    move |_: StatesData| {
      states_data_as_state_clone.set(StatesData {
        //received_state_one,
        //* Note the destructuring syntax;
        ..states_data_as_state_clone.deref().clone()
      });
    }
  );

  // Time to create a 'Callback::from' for receiving the counter of/from the &quot;FormButtonComponent&quot; defined up above
  // Note that since this Callback::from does not need any event
  // ..from its child component, its closure arg
  // ..uses a '_' to ignore args
  let click_count_receipient = Callback::from( move
    |_| {

      // In order to change the use_state &quot;form_button_click_count_clone&quot; as &quot;FormButtonComponent&quot; is being clicked,
      // ..you need to call 'set' on it, see below;
      let click_count = *form_button_click_count_clone;
      form_button_click_count_clone.set(click_count + 1);
    }
  );

  // &quot;StatesData&quot;: Time again to create a 'Callback::from' for the &quot;StatesData&quot; struct.
  // ..but before doing that, first clone the state for it
  // Here, we'll be updating the view based on a button's click count
  let states_data_as_state_clone = states_data_as_state.clone();

  // Callback::from() for states_data_as_state_clone's &quot;state_two&quot; property
  let _states_data_as_state_clone_button_count_callback_receipient = Callback::from(
    // This time we ignore closure arguments for 'Callback::from since we are not expecting nor working with any from its child component
    move |_: StatesData| {
      // deref &quot;states_data_as_state_clone&quot;, and clone it again :/ lol
      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two += 1;
      // Remember to set new &quot;StatesData&quot; struct clone changes as new state, like so;
      states_data_as_state_clone.set(states_data);
    }
  );

  // Use &lt;div&gt;&lt;/div&gt; instead of &lt;form&gt;&lt;/form&gt; for now
  // ..because using &lt;form&gt;&lt;/form&gt; as it is right now would lead to an endless recursive re-render of the screen
  html! {
    &lt;div&gt;
      &lt;FormInputComponent input_one={props.input_one_value.clone()} string_data_callback={callback_receipient} /&gt;
      {
        // Now you need to pass in your Callback::from to your child component's Callback property &quot;click_count&quot;
      }
      &lt;FormButtonComponent button_one={props.button_name.clone()} click_count={click_count_receipient}/&gt;

      {
        // Time to ouput our complex state struct's properties (which inversely themselves now states)
      }
      &lt;p&gt;{&quot;State 1 is: &quot;}{&amp;states_data_as_state.state_one}&lt;/p&gt;
      &lt;p&gt;{&quot;State 2 has &quot;}{&amp;states_data_as_state.state_two}{ &quot;clicks!&quot;}&lt;/p&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;

mod components;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;Texting with style!&quot;}
        &lt;/p&gt;
        &lt;span&gt;
          {&quot;cool eh!&quot;}
        &lt;/span&gt;

        &lt;LevelOneAComponent1 prop_one=&quot;hi&quot; /&gt;
        &lt;FormAssemblerComponent input_one=&quot;Input 1&quot; button_one=&quot;Button 1&quot; /&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="form---inputs-and-buttons-using-use-state-of-one-complex-struct-state-instead-of-multiple-states-think-buttons-and-counters-as-well"><a class="header" href="#form---inputs-and-buttons-using-use-state-of-one-complex-struct-state-instead-of-multiple-states-think-buttons-and-counters-as-well">Form - inputs and buttons using 'use-state' of one complex struct state instead of multiple states, think buttons and counters as well.</a></h2>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
     |-form_components
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembly_component.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] } // * Note this important feature.
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/main.css'</pre>
<pre><code class="language-css">p {
	background-color: yellowgreen;
	color: beige;
	border: 1px solid pink;
	border-radius: 50px;
	text-align: center;
	font-style: italic;
	font-size: 18px;
	padding: 5px;
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub prop_one: String,
    pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {
    html! {
      &lt;div&gt;

        &lt;hr/&gt;
        &lt;p&gt;{&quot;This is component 'SubComponentsAComponent1' from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'. It received the following Props field values from its parent component 'App' :&quot;}&lt;/p&gt;

        &lt;div&gt;
          &lt;ul&gt;
            &lt;li&gt;{&amp;props.prop_one}&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;
        &lt;hr style=&quot;border: 1px solid green;&quot;/&gt;

      &lt;/div&gt;
    }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one: String,
  pub string_data_callback: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let string_data_callback_clone = props.string_data_callback.clone();

  let emit_string_data_callback = Callback::from(

    move | input_event: Event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();

      string_data_callback_clone.emit(current_input_text.value());

    }

  );

  html! {
    {
      //* Notice how the input has a placeholder text which is the name you give to the input itself.
    }
    &lt;input type=&quot;text&quot; name={props.input_one.clone()} onchange={emit_string_data_callback} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
  // Create a Callback property to power click counts
  pub click_count_callback: Callback&lt;()&gt;,
}

#[function_component(FormButtonComponent)]
pub fn form_button_component(props: &amp;Props) -&gt; Html {

  // Clone &quot;click_count&quot; callback property. It's just good practice
  let click_count_callback_clone = props.click_count.clone();

  // Take note of &quot;counter_action&quot;
  let counter_action = Callback::from(
    move |_| {
      click_count_clone.emit(()); //* 'emit(())' because &quot;click_count&quot; is a Callback&lt;()&gt;
    }
  );
  html! {
    {
      // In order to perform count when clicked, you need to assign a Callback::from to the
      // ..button's 'onclick' attribute
    }
    &lt;button onclick={counter_action}&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component.rs'</pre>
<pre><code class="language-rust">use crate::components::form_components::form_button_component::FormButtonComponent;
use crate::components::form_components::form_input_component::FormInputComponent;
use yew::prelude::*;

use std::ops::Deref;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub input_one_value: String,
    //* Another property to satisfy second &quot;FormInputComponent&quot; 'name' attribute value requirement
    pub input_two_value: String,
    pub button_name: String,
}

//* A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
    pub input_state: String,
    pub clicks_count_state: u32,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

    // Pass in your &quot;StatesData&quot; struct as a 'use_state'.
    let states_data_as_state = use_state(|| StatesData::default());

    let states_data_as_state_clone = states_data_as_state.clone(); //* For &quot;input_callback_receipient&quot;

    let input_callback_receipient = Callback::from(move |received_current_input_text| {

        states_data_as_state_clone.set(
          StatesData {
            input_state: received_current_input_text,
            ..states_data_as_state_clone.deref().clone()
          }
        );

    });

    let states_data_as_state_clone = states_data_as_state.clone(); //* For &quot;click_count_callback_receipient&quot; below

    let click_count_callback_receipient = Callback::from(move |_| {

        let current_click_counts = states_data_as_state_clone.clicks_count_state.clone();

        states_data_as_state_clone.set(
          StatesData {
            clicks_count_state: current_click_counts + 1,
            ..states_data_as_state_clone.deref().clone()
          }
        )

    });

    // &lt;FormInputComponent input={&amp;props.input_two_value.clone()} callback_data={input_2_callback_receipient} /&gt;
    html! {
      &lt;div&gt;
        &lt;hr/&gt;
        &lt;p&gt;{&quot;This component 'FormAssemblerComponent' has Props with the following initial field values received from its parent component 'App' :&quot;}&lt;/p&gt;

        &lt;div&gt;
          &lt;ul&gt;
            &lt;li&gt;{&quot;input_one_value: &quot;}{&amp;props.input_one_value}&lt;/li&gt;
            &lt;li&gt;{&quot;input_two_value: &quot;}{&amp;props.input_two_value}&lt;/li&gt;
            &lt;li&gt;{&quot;button_name: &quot;}{&amp;props.button_name}&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;

        &lt;FormInputComponent input_one={props.input_one_value.clone()} string_data_callback={input_callback_receipient} /&gt;
        &lt;FormButtonComponent button_one={props.button_name.clone()} click_count_callback={click_count_callback_receipient}/&gt;

        &lt;p&gt;{&quot;State 1 is: &quot;}{&amp;*states_data_as_state.input_state}&lt;/p&gt;
        &lt;p&gt;{&quot;State 2 has &quot;}{&amp;states_data_as_state.clicks_count_state}{&quot; clicks!&quot;}&lt;/p&gt;
        &lt;hr style=&quot;border: 1px solid green;&quot;/&gt;
      &lt;/div&gt;
    }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;
use stylist::{yew::styled_component, Style};
use yew::prelude::*;

mod components;

const EXTERNAL_STYLE: &amp;str = include_str!(&quot;main.css&quot;);

#[styled_component(App)]
pub fn app() -&gt; Html {
    let external_style = Style::new(EXTERNAL_STYLE).unwrap();

    html! {
      &lt;&gt;
        &lt;div class={external_style}&gt;

          &lt;p&gt;
            {&quot;A Form Demo!&quot;}
          &lt;/p&gt;

          &lt;b&gt;
            {&quot;Please note that the html 'form' element is not used anywhere in this demo.&quot;}
          &lt;/b&gt;

          &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;
          &lt;FormAssemblerComponent input_one_value=&quot;Input 1&quot; input_two_value=&quot;Input 2&quot; button_name=&quot;Button 1&quot; /&gt;

        &lt;/div&gt;
      &lt;/&gt;
    }
}

</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;
fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="form---submitting-a-form"><a class="header" href="#form---submitting-a-form">Form - submitting a form</a></h2>
<p>Emit form data up to a callback. This time the HTML 'form' element will be used, and in order to mimic that form data has been passed, a form-assembler component would pass the form data up to its parent component via a callback.</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
      |-mod.rs
     |-form_components.rs
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembly_component.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub prop_one: String,
    pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {
    html! {
      &lt;div&gt;
        &lt;hr/&gt;
        &lt;p&gt;{&quot;This is component 'SubComponentsAComponent1' from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'. It received the following Props field values from its parent component 'App' :&quot;}&lt;/p&gt;
        &lt;div&gt;
          &lt;ul&gt;
            &lt;li&gt;{&amp;props.prop_one}&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;
        &lt;hr style=&quot;border: 1px solid green;&quot;/&gt;
      &lt;/div&gt;
    }
}

</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component.rs'</pre>
<pre><code class="language-rust">use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub input: String,
    pub string_data_callback: Callback&lt;String&gt;,
    pub input_placeholder_text: Option&lt;String&gt;,
}

#[function_component(FormInputComponent)]
pub fn form_input_component(props: &amp;Props) -&gt; Html {
    let string_data_callback_clone = props.string_data_callback.clone();

    let emit_string_data_callback = Callback::from(move |input_event: Event| {
        let input_event_target = input_event.target().unwrap();
        let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();

        string_data_callback_clone.emit(current_input_text.value());
    });

    html! {
      &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={emit_string_data_callback} placeholder={props.input_placeholder_text.clone()} /&gt;
    }
}

</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub button_one: String,
    // Create a Callback property to power click counts
    pub click_count: Callback&lt;()&gt;,
}

#[function_component(FormButtonComponent)]
pub fn form_button_component(props: &amp;Props) -&gt; Html {
    // Clone &quot;click_count&quot; callback property. It's just good practice
    let click_count_clone = props.click_count.clone();

    // Take note of &quot;counter_action&quot;
    let counter_action = Callback::from(move |_| {
        click_count_clone.emit(()); //* 'emit(())' because &quot;click_count&quot; is a Callback&lt;()&gt;
    });
    html! {
      &lt;button onclick={counter_action}&gt;{&amp;props.button_one}&lt;/button&gt;
    }
}

</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component.rs'</pre>
<pre><code class="language-rust">use crate::components::form_components::form_button_component::FormButtonComponent;
use crate::components::form_components::form_input_component::FormInputComponent;
use yew::prelude::*;

use std::ops::Deref;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub input_one_value: String,
    // * Another property to satisfy second &quot;FormInputComponent&quot; 'name' attribute value requirement
    pub input_two_value: String,
    pub button_name: String,
    // * The props-field 'on_sumbit_form_callback' will pass data up to parent component 'App'
    pub on_submit_form_callback: Callback&lt;StatesData&gt;,
}

//* A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
    pub input_state: String, // * populated by 'input_callback_receipient_1' for and from child component 'FormInputComponent' 'string_data_callback'
    pub clicks_count_state: u32, // * populated by 'clicks_count_callback_recipient_2' for and from child component 'FormButtonComponent' 'click_count'. It will record the number of times the submit button is clicked / form submissions.
    pub extra_message_state: String, // * populated by 'input_callback_receipient_2' for and from child component 'FormInputComponent' 'string_data_callback'
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {
    // Pass in your &quot;StatesData&quot; struct as a 'use_state'.
    let states_data_as_state = use_state(|| StatesData::default());

    let states_data_as_state_clone = states_data_as_state.clone(); //* For &quot;input_callback_receipient&quot; below

    let input_callback_receipient_1 = Callback::from(move |received_current_input_text| {
        states_data_as_state_clone.set(StatesData {
            input_state: received_current_input_text,
            ..states_data_as_state_clone.deref().clone()
        });
    });

    let states_data_as_state_clone = states_data_as_state.clone(); // * For &quot;click_count_callback_receipient&quot; below

    let click_count_callback_receipient = Callback::from(move |_: ()| {
        // ***
        let current_click_counts = states_data_as_state_clone.clicks_count_state.clone();
        states_data_as_state_clone.set(StatesData {
            clicks_count_state: current_click_counts + 1,
            ..states_data_as_state_clone.deref().clone()
        })
    });

    let states_data_as_state_clone = states_data_as_state.clone(); // * For &quot;input_2_callback_receipient&quot; below

    let input_callback_receipient_2 = Callback::from(move |received_current_input_text| {
        states_data_as_state_clone.set(StatesData {
            extra_message_state: received_current_input_text,
            ..states_data_as_state_clone.deref().clone()
        })
    });

    let states_data_as_state_clone = states_data_as_state.clone(); // ***
    let on_submit_form_callback_clone = props.on_submit_form_callback.clone();

    //* Now create a 'Callback::from' to pass data up to its parent compoent when clicked (i.e, when the form is supported)
    //* *This is perhaps the most important, most critical code piece in this code demo.
    let on_submit_callback = Callback::from(
        // * Keyword 'move' necessary because &quot;states_data&quot; will be emitted herein
        move |onsubmit_event_trigger: FocusEvent| {
            // * First thing to do here in this callback closure is to prevent default to stop repetitive hot-reloading
            onsubmit_event_trigger.prevent_default();

            on_submit_form_callback_clone.clone().emit(StatesData {
                ..states_data_as_state_clone.deref().clone()
            });
        },
    );

    // &lt;FormInputComponent input={&amp;props.input_two_value.clone()} callback_data={input_2_callback_receipient} /&gt;
    // * Do notice that in the returned HTML code, a form is used this, and an action is carried out upon submitting the form
    html! {
      &lt;form onsubmit={on_submit_callback}&gt;

        &lt;hr/&gt;
        &lt;p&gt;{&quot;This component 'FormAssemblerComponent' has Props with the following initial field values received from its parent component 'App' :&quot;}&lt;/p&gt;

        &lt;div&gt;
          &lt;ul&gt;
            &lt;li&gt;{&quot;input_one_value: &quot;}{&amp;props.input_one_value}&lt;/li&gt;
            &lt;li&gt;{&quot;input_two_value: &quot;}{&amp;props.input_two_value}&lt;/li&gt;
            &lt;li&gt;{&quot;button_name: &quot;}{&amp;props.button_name}&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;

        &lt;div style=&quot;margin-top: 2px; margin-bottom: 2px;&quot;&gt;
          &lt;FormInputComponent input={props.input_one_value.clone()} string_data_callback={input_callback_receipient_1} /&gt;
        &lt;/div&gt;
        &lt;div style=&quot;margin-top: 2px; margin-bottom: 2px;&quot;&gt;
          &lt;FormInputComponent input={props.input_two_value.clone()} string_data_callback={input_callback_receipient_2} /&gt;
        &lt;/div&gt;
        &lt;div style=&quot;margin-top: 2px; margin-bottom: 2px;&quot;&gt;
          &lt;FormButtonComponent button_one={props.button_name.clone()} click_count={click_count_callback_receipient} /&gt;
        &lt;/div&gt;

        &lt;p&gt;{&quot;'StateData.input_state' value is: &quot;}{&amp;*states_data_as_state.input_state}&lt;/p&gt;
        &lt;p&gt;{&quot;'StateData.clicks_count_state' value is: &quot;}{&amp;states_data_as_state.clicks_count_state}{&quot; clicks!&quot;}&lt;/p&gt;
        &lt;p&gt;{&quot;'StateData.extra_message' value is: &quot;}{&amp;*states_data_as_state.extra_message_state}&lt;/p&gt;
        &lt;hr style=&quot;border: 1px solid green;&quot;/&gt;

      &lt;/form&gt;
    }
}

</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;
use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;
use stylist::{yew::styled_component, Style};
use yew::prelude::*;

use gloo::console::log;

mod components;

const EXTERNAL_STYLE: &amp;str = include_str!(&quot;main.css&quot;);

#[styled_component(App)]
pub fn app() -&gt; Html {
    let external_style = Style::new(EXTERNAL_STYLE).unwrap();

    // * Create a receipient for your child component's &quot;states_data&quot; callback property
    // * ..and do anything with it; send it, log it, anything. This could be where you write code logic to submit form data.
    let on_submit_form_callback_property_receipient = Callback::from(
        //* Remember to type-annotate &quot;received_states_data&quot; so the compiler can know what data type it is.
        |received_states_data: StatesData| {
            log!(
                &quot;State 1 (an input) form-data is: &quot;,
                received_states_data.input_state.clone()
            );
            log!(
                &quot;State 2 (click-count) form-data is: &quot;,
                received_states_data.clicks_count_state
            );
            log!(
                &quot;State 3 (message input) form-data is: &quot;,
                received_states_data.extra_message_state.clone()
            );
        },
    );

    html! {
      &lt;&gt;
        &lt;div class={external_style}&gt;

          &lt;p&gt;
            {&quot;A Form Demo!&quot;}
          &lt;/p&gt;

          &lt;b&gt;
            {&quot;Please note that the html 'form' element is being used this demo, and form submission action is being simulated. Please open your Developer console to see the form data that is being simulated as submitted.&quot;}
          &lt;/b&gt;

          &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;
          &lt;FormAssemblerComponent
            input_one_value=&quot;Input 1&quot;
            input_two_value=&quot;Input 2&quot;
            button_name=&quot;Button 1 (now a submit button too)&quot;
            on_submit_form_callback={on_submit_form_callback_property_receipient} /&gt;

        &lt;/div&gt;
      &lt;/&gt;
    }
}

</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hook---use_context"><a class="header" href="#hook---use_context">Hook - 'use_context'</a></h2>
<p>This mini-project demonstrates an immutable context</p>
<p>Allows you to have a use_context object that can be shared (but never mutable) amongst children components or descendants of a particular child of a particular parent component and with this object you can share data between components that does require being added as a property to each component the data is being shared between.</p>
<p>N.B: You need to use the built-in 'ContextProvider' generic component to create a context.
Also, when you change data inside a context, all the children or descendants with access to the context would get re-rendered. Take note of this so you're not making too many frequent changes to context data which can be expensive and impact overall user-perceived app performance.</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembly_component.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub prop_one: String,
    pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(props: &amp;Props) -&gt; Html {
    html! {
      &lt;div&gt;
        &lt;hr/&gt;
        &lt;p&gt;{&quot;This is component 'SubComponentsAComponent1' from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'. It received the following Props field values from its parent component 'App' :&quot;}&lt;/p&gt;
        &lt;div&gt;
          &lt;ul&gt;
            &lt;li&gt;{&amp;props.prop_one}&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;
        &lt;hr style=&quot;border: 1px solid green;&quot;/&gt;
      &lt;/div&gt;
    }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub input: String,
    pub string_data_callback: Callback&lt;String&gt;,
    pub input_placeholder_text: Option&lt;String&gt;,
}

#[function_component(FormInputComponent)]
pub fn form_input_component(props: &amp;Props) -&gt; Html {
    let string_data_callback_clone = props.string_data_callback.clone();

    let emit_string_data_callback = Callback::from(move |input_event: Event| {
        let input_event_target = input_event.target().unwrap();
        let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();

        string_data_callback_clone.emit(current_input_text.value());
    });

    html! {
      &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={emit_string_data_callback} placeholder={props.input_placeholder_text.clone()} /&gt;
    }
}

</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub button_one: String,
    // Create a Callback property to power click counts
    pub click_count: Callback&lt;()&gt;,
}

#[function_component(FormButtonComponent)]
pub fn form_button_component(props: &amp;Props) -&gt; Html {
    // Clone &quot;click_count&quot; callback property. It's just good practice
    let click_count_clone = props.click_count.clone();

    // Take note of &quot;counter_action&quot;
    let counter_action = Callback::from(move |_| {
        click_count_clone.emit(()); //* 'emit(())' because &quot;click_count&quot; is a Callback&lt;()&gt;
    });
    html! {
      &lt;button onclick={counter_action}&gt;{&amp;props.button_one}&lt;/button&gt;
    }
}

</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use crate::components::form_components::form_button_component::FormButtonComponent;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::ContextData;
use yew::prelude::*;

use gloo::console::log;
use std::ops::Deref;

#[derive(Properties, PartialEq)]
pub struct Props {
    pub input_one_value: String,
    pub input_two_value: String,
    pub button_one_name: String,
    pub button_two_name: Option&lt;String&gt;,
    pub on_submit_callback_property: Callback&lt;StatesData&gt;,
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
    pub state_one: String,
    pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {
    // Pass in your &quot;StatesData&quot; struct as a 'use_state'.
    let states_data_as_state = use_state(|| StatesData::default());

    //* For receiving a context, you need to apply a 'use_context' like so;
    let use_context_for_context_data = use_context::&lt;ContextData&gt;(); //* It will automatically now have access to &quot;ContextData&quot; because you opted in for access.

    let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

    let input_1_callback_receipient = Callback::from(move |received_current_input_text| {
        let mut states_data = states_data_as_state_clone.deref().clone();
        states_data.state_one = received_current_input_text;
        states_data_as_state_clone.set(states_data);
    });

    let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

    let input_2_callback_receipient = Callback::from(move |received_current_input_text| {
        let mut states_data = states_data_as_state_clone.deref().clone();
        states_data.state_two = received_current_input_text;
        states_data_as_state_clone.set(states_data);
    });

    // * For 'click_callback_receipient_1' below
    let states_data_as_state_clone = states_data_as_state.clone();

    let click_callback_receipient_1 = Callback::from(move |_: ()| {
        log!(&quot;1st button clicked&quot;);
        //let states_data_value = *states_data_as_state_clone.clone();
        // ***
        //let current_click_counts = states_data_as_state_clone.clicks_count_state.clone();
        states_data_as_state_clone.set(StatesData {
            //clicks_count_state: current_click_counts + 1, // * Please delete
            ..states_data_as_state_clone.deref().clone()
        })
    });

    // * For 'click_callback_receipient_2' below
    let states_data_as_state_clone = states_data_as_state.clone();

    let click_callback_receipient_2 = Callback::from(move |_: ()| {
        log!(&quot;2nd button clicked&quot;);
        // ***
        //let current_click_counts = states_data_as_state_clone.clicks_count_state.clone(); // * Please delete
        states_data_as_state_clone.set(StatesData {
            //clicks_count_state: current_click_counts + 1,
            ..states_data_as_state_clone.deref().clone()
        })
    });

    // Clone received &quot;props&quot; 's &quot;on_submit_callback_property&quot; since you would be emitting it eventually
    let prop_on_submit_callback_property_clone = props.on_submit_callback_property.clone();

    // Also clone state &quot;StatesData&quot; - &quot;states_data_as_state&quot;
    let states_data_as_state_clone = states_data_as_state.clone();

    // This is a critical code piece in this code demo
    let on_submit_callback = Callback::from(move |onsubmit_event_trigger: FocusEvent| {
        onsubmit_event_trigger.prevent_default();
        let states_data = states_data_as_state_clone.deref().clone();
        // emit &quot;states_data&quot;
        prop_on_submit_callback_property_clone.emit(states_data);
    });

    //* Unlike before, now you can use &lt;form&gt;&lt;/form&gt; instead of &lt;div&gt;&lt;/div&gt;
    html! {
      &lt;form onsubmit={on_submit_callback}&gt;

        &lt;FormInputComponent input={props.input_one_value.clone()} string_data_callback={input_1_callback_receipient} /&gt;
        &lt;FormInputComponent input={props.input_two_value.clone()} string_data_callback={input_2_callback_receipient} /&gt;

        &lt;FormButtonComponent button_name={props.button_one_name.clone()} click_callback={click_callback_receipient_1} /&gt;
        &lt;FormButtonComponent button_name={
            match props.button_two_name.clone() {
                Some(string_value) =&gt; string_value.clone(),
                _ =&gt; &quot;&quot;.to_string()
            }
        } click_callback={click_callback_receipient_2} /&gt;

        &lt;p&gt;{&quot;State 1 is: &quot;}{&amp;states_data_as_state.state_one}&lt;/p&gt;
        &lt;p&gt;{&quot;State 2 is: &quot;}{&amp;states_data_as_state.state_two}&lt;/p&gt;

        &lt;p&gt;
          {&quot;use_context_for_context_data's context_data_one is: &quot;}
          {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
        &lt;/p&gt;
        &lt;p&gt;
          {&quot;use_context_for_context_data's context_data_two is: &quot;}
          {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
        &lt;/p&gt;

      &lt;/form&gt;
    }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;
use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;
use stylist::{yew::styled_component, Style};
use yew::prelude::*;
//* You have to use 'ContextProvider' at the place where you want to create a context object.
//* ..and you would then wrap your target context data with ContextProvider; as in: &quot;ContextProvider&lt;MyContextWhichIsAStruct&gt;
use yew::ContextProvider;
use gloo::console::log;

mod components;

const EXTERNAL_STYLE: &amp;str = include_str!(&quot;main.css&quot;);

//* Create data (in this chosen case, a struct) which will be a context data available to sub-components (child components and/or descendant components of a child component)
//* Your context data struct must implement 'Clone' and 'PartialEq'
//* Also optionally derive &quot;Default&quot;
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
    pub context_data_one: String,
    pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {
    let external_style = Style::new(EXTERNAL_STYLE).unwrap();

    //* Instantiate &quot;ContextData&quot;
    let context_data_instance = ContextData {
        context_data_one: &quot;context data 1&quot;.to_owned(),
        context_data_two: &quot;context data 2&quot;.to_owned(),
    };

    let on_submit_callback_property_receipient =
        Callback::from(|received_states_data: StatesData| {
            log!(&quot;State 1 is: &quot;, received_states_data.state_one);
            log!(&quot;State 2 is: &quot;, received_states_data.state_two);
        });

    html! {
      &lt;&gt;
        &lt;div class={external_style}&gt;

          &lt;p&gt;
            {&quot;ContextProvider demo code mini-project&quot;}
          &lt;/p&gt;

          &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;

          &lt;ContextProvider&lt;ContextData&gt; context={context_data_instance}&gt;
            &lt;FormAssemblerComponent
              input_one_value = &quot;Input 1&quot;
              input_two_value =&quot;Input 2&quot;
              button_one_name = &quot;Submit&quot;
              button_two_name = {Some(&quot;Check&quot;.to_string())}
              on_submit_callback_property = {on_submit_callback_property_receipient}
            /&gt;
          &lt;/ContextProvider&lt;ContextData&gt;&gt;

        &lt;/div&gt;
      &lt;/&gt;
    }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hook---use_context-1"><a class="header" href="#hook---use_context-1">Hook - 'use_context'</a></h2>
<p>This mini-project demos a mutable context (using a 'use_state' to enable mutability).</p>
<p>You would be able to have a use_context object that can be shared (and mutable) amongst children components or descendants of a particular child of a particular parent component and with this object you can share data between components that does require being added as a property to each component the data is being shared between.</p>
<p>N.B: You need to use the built-in 'ContextProvider' generic component to create a context.
Also, when you change data inside a context, all the children or descendants with access to the context would get re-rendered. Take note of this so you're not making too many frequent changes to context data which can be expensive and impact overall user-perceived app performance.</p>
<p>IMPOROTANT:
The concept here is that your sub-components receive context data which you can mutate internally and then pass up to the parent component. Likewise, a parent component can mutate context data which would trickle down and be reflected inside sub-components.</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component;
use crate::components::form_components::form_button_component;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  // Pass in your &quot;StatesData&quot; struct as a 'use_state'.
  let states_data_as_state = use_state( || StatesData::default() );

  //* For receiving a context, you need to apply a 'use_context' like so;
  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); //* It will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // Clone received &quot;props&quot; 's &quot;on_submit_callback_property&quot; since you would be emitting it eventually
  let prop_on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // Also clone state &quot;StatesData&quot; - &quot;states_data_as_state&quot;
  let states_data_as_state_clone = states_data_as_state.clone();

  // This is a critical code piece in this code demo
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      prop_on_submit_callback_property_clone.emit(states_data);

    }
  );

  //* Unlike before, now you can use &lt;form&gt;&lt;/form&gt; instead of &lt;div&gt;&lt;/div&gt;
  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;

      {
        //* &quot;click_count&quot; in code below not needed anymore
      }
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} click_count={click_count_callback_receipient}/&gt;
      {
        //* Here is the replacement
      }
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      &lt;p&gt;{&quot;State 1 is: &quot;}{&amp;states_data_as_state.state_one}&lt;/p&gt;

      {
        //* Time to use context data trickled down from parent component
        //* ..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default()context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;
//* You have to use 'ContextProvider' at the place where you want to create a context object.
//* ..and you would then wrap your target context data with ContextProvider; as in: &quot;ContextProvider&lt;MyContextWhichIsAStruct&gt;
use yew::ContextProvider;

mod components;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

//* Create data (in this chosen case, a struct) which will be a context data available to sub-components (child components and/or descendant components of a child component)
//* Your context data struct must implement 'Clone' and 'PartialEq'
//* Also optionally derive &quot;Default&quot;
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  /*
  // * Remove this, not needed any longer
  // Instantiate &quot;ContextData&quot;
  let context_data_instance = ContextData {
    context_data_one: &quot;context data 1&quot;.to_owned(),
    context_data_two: &quot;context data 2&quot;.to_owned(),
  }
  */

  //* Create a 'use_state' providing &quot;ContextData&quot; as a state
  // let context_data_as_state = use_state(|| ContextData::default());
  let context_data_as_state = use_state(ContextData::default); //* better syntax herein

  /*
  // * Replace this with a block
  let on_submit_callback_property_receipient = Callback::from(
    |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = received_state_data.state_one;
      context_data.context_data_two = received_state_date.state_two;
      context_data_as_state.set(context_data);
    }
  );
  */

  //* Block replacement:
  let on_submit_callback_property_receipeint = {
    //* Clone &quot;context_data_as-state&quot; so you transfer its ownership here
    let context_data_as_state = context_data_as_state.clone();
    Callback::from(
      // * N.B: Since you will be passing data down to sub-components via a 'use_context',
      // * ..you need to move the data out of the closure, like so;
      move |received_states_data: StatesData| {
        //* You have access to 'StatesData' courtesy of being inside a callback receipient :-)
        let mut context_data = context_data_as_state.deref().clone();
        context_data.context_data_one =  received_states_data.state_one;
        context_data.context_data_two =  received_states_data.state_two;
        //* Now set &quot;context_data_as_state&quot; state to the new updated version, which is &quot;context_data&quot;
        context_data_as_state.set(context_data);
      }
    )//* Remove semi-colon here ;
  }; //* I personally find the prior version easier to read still though

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;ContextProvider demo code mini-project&quot;}
        &lt;/p&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;
        {
          //* &quot;ContextProvider&quot; with &quot;ContextData&quot; data type
          //* This time, instead of assigning an instance of &quot;ContextData&quot; to its 'context' attribute, like so;
          //* 'context={context_data_instance}
          //* ..You'd assign &quot;context_data_as_state.deref().clone()&quot; to 'context', like so;
        }
        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hook---use_effect"><a class="header" href="#hook---use_effect">Hook - 'use_effect'</a></h2>
<p>Run or perform actions immediately a component is rendering for the first time or perform actions every time a component re-renders. You could also destroy data causing a use_effect'inside 'use_effect' itself</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
  <pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form-components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(LevelOneAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component;
use crate::components::form_components::form_button_component;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  let states_data_as_state = use_state( || StatesData::default() );

  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); // This component will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // &quot;on_submit_callback_property&quot; is a Callback' type property
  let prop_on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // Also clone state &quot;StatesData&quot; - &quot;states_data_as_state&quot; since the clone will be .deref() and cloned
  let states_data_as_state_clone = states_data_as_state.clone();

  // The callback function here is sensitive to an 'onsubmit' event, which causes it do send (emit) data up to its parent
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      prop_on_submit_callback_property_clone.emit(states_data);

    }
  );

  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      {
        // Now redundant since the next two p-tags ouput &quot;state_one&quot; via &quot;contex_data_one&quot; proxy (which was assigned the original value of &quot;state_one&quot;)
      }
      &lt;p&gt;{&quot;State 1 is: &quot;}{&amp;states_data_as_state.state_one}&lt;/p&gt;

      {
        // Time to use context data trickled down from parent component
        //..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;
// You create a 'ContextProvider' at the place where you want to create a context data / object.
use yew::ContextProvider;

mod components;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

// &quot;ContextData&quot; will be used as a context object
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  // Create a 'use_state' providing &quot;ContextData&quot; as a state
  // let context_data_as_state = use_state(|| ContextData::default());
  let context_data_as_state = use_state(ContextData::default); // better syntax herein

  //* Pay attention to 'use_effect' description
  //*
  //* To make sure that your 'use_effect runs only once, create a bool state, e.g; &quot;first_run
  let first_run = use_state( || true);

  //* The use_effect
  use_effect(
    move || {
      //* Run a if condition using bool &quot;first_run&quot;
      if *first_run {
        // perform an action to be run once here inside the if-block instead
        //* Remember to set &quot;first_run&quot; to false so the use_effect code action does not get run again after the first run
        first_run.set(false);
      }
      //* 'use_effect' expects a closure to be run. It could be an empty closure though, as is here;
      || {} //* Note that you could destroy/drop data inside this closure as well
    }
  );

  /*
  // Replace this with a block
  let on_submit_callback_property_receipient = Callback::from(
    move |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = received_states_data.state_one;
      context_data.context_data_two = received_states_data.state_two;
      context_data_as_state.set(context_data);
    }
  );
  */

  // Block replacement:
  let on_submit_callback_property_receipeint = {
    // Clone and shadow &quot;context_data_as-state&quot; so you transfer its ownership to &quot;Callback::from&quot; here below
    let context_data_as_state = context_data_as_state.clone();
    Callback::from(
      // N.B: Since you will be passing data down to sub-components via a 'use_context',
      // ..you need to move the data out of the closure, like so;
      move |received_states_data: StatesData| {
        // You have access to 'StatesData' courtesy of being inside a callback receipient :-)
        let mut context_data = context_data_as_state.deref().clone();
        context_data.context_data_one =  received_states_data.state_one;
        context_data.context_data_two =  received_states_data.state_two;
        // Now set &quot;context_data_as_state&quot; state to the new updated version, which is &quot;context_data&quot;
        context_data_as_state.set(context_data);
      }
    )
  }; // I personally find the prior version easier to read still though

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;ContextProvider demo code mini-project&quot;}
        &lt;/p&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;

        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew-project-name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yew-router---browserrouter"><a class="header" href="#yew-router---browserrouter">Yew router - 'BrowserRouter'</a></h2>
<p>Render components based on the url entered on a browser's address bar.</p>
<p><code>New file &quot;yew_project_name::src::router.rs&quot; created</code>
<code>New dir &quot;yew_project_name::src::components::routes&quot; created</code></p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
    |-routes
     |-mod.rs
     |-home.rs
     |-route_one.rs
     |-route_two.rs
    |-lib.rs
    |-main.rs
    |-router.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
yew-router = &quot;0.16.0&quot; </p>
<h1 id="-you-need-to-depend-on-yew-router"><a class="header" href="#-you-need-to-depend-on-yew-router">//* You need to depend on yew-router</a></h1>
</pre>
</code>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
//* expose newly created &quot;routes&quot; dir
pub mod routes;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(LevelOneAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component;
use crate::components::form_components::form_button_component;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  let states_data_as_state = use_state( || StatesData::default() );

  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); // This component will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // &quot;on_submit_callback_property&quot; is a Callback' type property
  let on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // To be .deref() and cloned later
  let states_data_as_state_clone = states_data_as_state.clone();

  // The callback function here is sensitive to an 'onsubmit' event, which causes it do send (emit) data up to its parent
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      on_submit_callback_property_clone.emit(states_data);

    }
  );

  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      {
        // Time to use context data trickled down from parent component
        //..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/mod.rs'</pre>
<pre><code class="language-rust">//* expose sibling Rust files 'home.rs', 'route_one.rs' and 'route_two.rs'
pub mod home.rs;
pub mod route_one.rs;
pub mod route_two.rs;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/home.rs'</pre>
<pre><code class="language-rust">//* Create Home component

use yew::prelude::*;

#[function_component(Home)]
pub fn home() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside the landing homepage!&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/router_one.rs'</pre>
<pre><code class="language-rust">//* Create RouterOne component
use yew::prelude::*;

#[function_component(RouterOne)]
pub fn router_one() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-one&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/route_two.rs'</pre>
<pre><code class="language-rust">//* Create RouterTwo component
use yew::prelude::*;

#[function_component(RouterTwo)]
pub fn router_two() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-two&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/router.rs'</pre>
<pre><code class="language-rust">//* Create &quot;router.rs&quot;

use yew::prelude::*;
//* You must use 'yew_router' crate prelude to be able to create public enum &quot;Route&quot; which must implement 'Routable'
use yew_router::prelude;

//* use the components which are your routes, e.g, home.rs's Home component
use crate::components::router::home::Home;
use crate::components::router::route_one::RouteOne;
use crate::components::router::route_two::RouteTwo;

//* Create a public enum &quot;Route&quot; to map your router links (i.e, routing by name)
//* ..and &quot;Route&quot; must implement 'Routable', Clone, and 'PartialEq'
#[derive(Debug, Clone, PartialEq, Routable)]
pub enum Route {
  #[at(&quot;/&quot;)]
  LandingPage,
  #[at(&quot;/route-one&quot;)]
  RouteOne,
  #[at(&quot;/route-two&quot;)]
  RouteTwo,
}

//* You need to create a function 'switch'
pub fn switch(route: &amp;Route) -&gt; Html {
  match route {
    Route::Home =&gt; html! { &lt;Home /&gt; },
    Route::RouteOne =&gt; html! { &lt;RouterOne /&gt; },
    Route::RouteTwo =&gt; html! { RouterTwo /&gt; },
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::LevelOneAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;
// You create a 'ContextProvider' at the place where you want to create a context data / object.
use yew::ContextProvider;
//* You must use 'yew_router::prelude::*' in order to be able to use '&lt;Switch /&gt;' nested inside '&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;'
use yew_router::prelude::*;
//* You must also use the &quot;switch&quot; function and &quot;Route&quot; enum inside &quot;yew_project_name/src/router.rs&quot;
use crate::router::{Router, switch};

pub mod components;
//* expose sibling '.rs' file &quot;router.rs&quot;
pub mod router;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

// &quot;ContextData&quot; will be used as a context object
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  let context_data_as_state = use_state(ContextData::default); // or 'use_state( || ContextData::default() ) '

  let first_run = use_state( || true);

  use_effect(
    move || {
      if *first_run {
        first_run.set(false);
      }
      || {} // Note that you could destroy/drop data inside this closure as well
    }
  );

  let on_submit_callback_property_receipient = Callback::from(
    |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = recieved_states_data.state_one;
      context_data.context_data_two = received_states_data.state_two;
      context_data_as_state.set(context_data);
    }
  );

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;ContextProvider demo code mini-project&quot;}
        &lt;/p&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;

        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            prop_on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
          {
            //* Time to use 'BrowserRouter'. IMPORTANT: There is no way to pass properties into a Yew router, i.e 'BrowserRouter',
            //* ..but.. you can use a Context as a proxy to pass data. Mind you every sibling component of the 'BrowserRouter' would also have access
            //* ..to the data as well which may be undesireable.
            //* Also, imagine sibling component &quot;LevelOneAComponent1&quot; plausibly being used as a nav-menu component ;-)
            //* &quot;Route&quot; here is an enum, &quot;switch&quot; is a function which matches a &quot;Route&quot; variant to an actual route component.
          }
          &lt;BrowserRouter&gt;
            &lt;Switch&lt;Route&gt;
              render={Switch::render{switch}}
            /&gt;
          &lt;BrowserRouter&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="linking-between-components-using-programmatic-link"><a class="header" href="#linking-between-components-using-programmatic-link">Linking between components using programmatic Link</a></h2>
<p>Render components based on the url entered on a browser's address bar. A 'Link' is compiled down to a-tags in the end</p>
<p>You may want to jump to file: 'yew_project_name/src/components/routes/home.rs' for a quick look!</p>
<p><code>New file &quot;yew_project_name::src::router.rs&quot; created</code></p>
<p><code>New dir &quot;yew_project_name::src::components::routes&quot; created</code></p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
    |-routes
     |-mod.rs
     |-home.rs
     |-route_one.rs
     |-route_two.rs
    |-lib.rs
    |-main.rs
    |-router.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;</p>
<h1 id="-you-need-to-depend-on-yew-router-1"><a class="header" href="#-you-need-to-depend-on-yew-router-1">//* You need to depend on yew-router</a></h1>
<p>yew-router = &quot;0.16.0&quot; 
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
//* expose newly created &quot;routes&quot; dir
pub mod routes;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  let states_data_as_state = use_state( || StatesData::default() );

  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); // This component will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // &quot;on_submit_callback_property&quot; is a Callback' type property
  let on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // To be .deref() and cloned later
  let states_data_as_state_clone = states_data_as_state.clone();

  // The callback function here is sensitive to an 'onsubmit' event, which causes it do send (emit) data up to its parent
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      on_submit_callback_property_clone.emit(states_data);

    }
  );

  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      {
        // Time to use context data trickled down from parent component
        //..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/mod.rs'</pre>
<pre><code class="language-rust">pub mod home.rs;
pub mod route_one.rs;
pub mod route_two.rs;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/home.rs'</pre>
<pre><code class="language-rust">// Create Home component

use yew::prelude::*;

//* 'Since Link is inside 'yew_router::prelude::*', you must use it
use yew_router::prelude::*;
//* You must also use the actual &quot;Route&quot; enum which Link would wrap around
use crate::router::Route;

#[function_component(Home)]
pub fn home() -&gt; Html {
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside the landing homepage!&quot;}&lt;/p&gt;
      {
        //* Time to make a Link to another component without refreshing the page
      }
      &lt;div&gt;
        &lt;Link&lt;Route&gt;
          to={Route::RouteOne}&gt;{ &quot;Go to 'RouteOne' with no page refresh&quot; }
        &lt;/Link&lt;Route&gt;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/router_one.rs'</pre>
<pre><code class="language-rust">// Create RouterOne component

use yew::prelude::*;

#[function_component(RouterOne)]
pub fn router_one() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-one&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/route_two.rs'</pre>
<pre><code class="language-rust">// Create RouterTwo component

use yew::prelude::*;

#[function_component(RouterTwo)]
pub fn router_two() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-two&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/router.rs'</pre>
<pre><code class="language-rust">// Create &quot;router.rs&quot;

use yew::prelude::*;
// You must use 'yew_router' crate prelude to be able to create public enum &quot;Route&quot; which must implement 'Routable'
use yew_router::prelude;

// use the components which are your routes, e.g, home.rs's Home component
use crate::components::router::home::Home;
use crate::components::router::route_one::RouteOne;
use crate::components::router::route_two::RouteTwo;

// Create a public enum &quot;Route&quot; to map your router links (i.e, routing by name)
// ..and &quot;Route&quot; must implement 'Routable', Clone, and 'PartialEq'
#[derive(Debug, Clone, PartialEq, Routable)]
pub enum Route {
  #[at(&quot;/&quot;)]
  LandingPage,
  #[at(&quot;/route-one&quot;)]
  RouteOne,
  #[at(&quot;/route-two&quot;)]
  RouteTwo,
}

// You need to create a function 'switch' to return proper component based on enum 'Route'
pub fn switch(route: &amp;Route) -&gt; Html {
  match route {
    Route::Home =&gt; html! { &lt;Home /&gt; },
    Route::RouteOne =&gt; html! { &lt;RouterOne /&gt; },
    Route::RouteTwo =&gt; html! { RouterTwo /&gt; },
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;

// You create a 'ContextProvider' at the place where you want to create a context data / object.
use yew::ContextProvider;

// You must use 'yew_router::prelude::*' in order to be able to use '&lt;Switch /&gt;' nested inside '&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;'
use yew_router::prelude::*;

// You must also use the &quot;switch&quot; function and &quot;Route&quot; enum inside &quot;yew_project_name/src/router.rs&quot;
use crate::router::{Router, switch};

pub mod components;
// &quot;router&quot; is a Rust file not a dir, unlike &quot;components&quot;
pub mod router;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

// &quot;ContextData&quot; will be used as a context object
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  let context_data_as_state = use_state(ContextData::default); // or 'use_state( || ContextData::default() ) '

  let first_run = use_state( || true);

  use_effect(
    move || {
      if *first_run {
        first_run.set(false);
      }
      || {} // Note that you could destroy/drop data inside this closure as well
    }
  );

  let on_submit_callback_property_receipient = Callback::from(
    |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = recieved_states_data.state_one;
      context_data.context_data_two = received_states_data.state_two;
      context_data_as_state.set(context_data);
    }
  );

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;ContextProvider demo code mini-project&quot;}
        &lt;/p&gt;

        &lt;LevelOneAComponent1 prop_one=&quot;hi&quot; /&gt;

        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            prop_on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
          {
            // Time to use 'BrowserRouter'. IMPORTANT: There is no way to pass properties into a Yew router, i.e 'BrowserRouter',
            // ..but.. you can use a Context as a proxy to pass data. Mind you every sibling component of the 'BrowserRouter' would also have access
            // ..to the data as well which may be undesireable.
            // Also, imagine sibling component &quot;LevelOneAComponent1&quot; plausibly being used as a nav-menu component ;-)
            // &quot;Route&quot; here is an enum, &quot;switch&quot; is a function which matches a &quot;Route&quot; variant to an actual route component.
          }
          &lt;BrowserRouter&gt;
            &lt;Switch&lt;Route&gt;
              render={Switch::render{switch}}
            /&gt;
          &lt;BrowserRouter&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hook---use_history-for-programmatically-linking-between-components"><a class="header" href="#hook---use_history-for-programmatically-linking-between-components">Hook - 'use_history' for programmatically linking between components.</a></h2>
<p>Render a component when a button is clicked, but be able to run some code in response to the click using a 'Callback::from' and 'use_history'.</p>
<p>You may want to jump to file: 'yew_project_name/src/components/routes/routes_two.rs' for a quick look!</p>
<pre>New file "yew_project_name::src::router.rs" created</pre>
<pre>New dir "yew_project_name::src::components::routes" created</pre>
<pre>File "yew_project_name::src::components::routes::route_one" will be used for the demonstration</pre>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
    |-routes
     |-mod.rs
     |-home.rs
     |-route_one.rs
     |-route_two.rs
    |-lib.rs
    |-main.rs
    |-router.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
yew-router = &quot;0.16.0&quot; </p>
<h1 id="--you-need-to-depedn-on-yew-router"><a class="header" href="#--you-need-to-depedn-on-yew-router">// * You need to depedn on yew-router</a></h1>
</pre>
</code>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
//* expose newly created &quot;routes&quot; dir
pub mod routes;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  let states_data_as_state = use_state( || StatesData::default() );

  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); // This component will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // &quot;on_submit_callback_property&quot; is a Callback' type property
  let on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // To be .deref() and cloned later
  let states_data_as_state_clone = states_data_as_state.clone();

  // The callback function here is sensitive to an 'onsubmit' event, which causes it do send (emit) data up to its parent
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      on_submit_callback_property_clone.emit(states_data);

    }
  );

  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      {
        // Time to use context data trickled down from parent component
        //..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/mod.rs</pre>
<pre><code class="language-rust">pub mod home.rs;
pub mod route_one.rs;
pub mod route_two.rs;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/home.rs'</pre>
<pre><code class="language-rust">// Create Home component

use yew::prelude::*;

// 'Since Link is inside 'yew_router::prelude::*', you must use it
use yew_router::prelude::*;
// You must also use the actual &quot;Route&quot; enum which Link would wrap around
use crate::router::Route;

#[function_component(Home)]
pub fn home() -&gt; Html {
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside the landing homepage!&quot;}&lt;/p&gt;
      {
        // Time to make a Link to another component without refreshing the page
      }
      &lt;div&gt;
        &lt;Link&lt;Route&gt;
          to={Route::RouteOne}&gt;{ &quot;Go to 'RouteOne' with no page refresh&quot; }
        &lt;/Link&lt;Route&gt;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/router_one.rs'</pre>
<pre><code class="language-rust">// Create RouterOne component

use yew::prelude::*;

#[function_component(RouterOne)]
pub fn router_one() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-one&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/route_two.rs'</pre>
<pre><code class="language-rust">// Create RouterTwo component

//* Focus on this very particular component

use yew::prelude::*;
//* In order to apply 'use_history', you need to use 'yew_router::prelude::*;'
//* ..and 'use_history' itself
use yew_router::{prelude::*, history};

#[function_component(RouterTwo)]
pub fn router_two() -&gt; Html {

  //* Time to apply 'use_history'
  let history = use_history().unwrap();

  //* Clone the applied history in cas you may use &quot;history&quot; multiple times
  let history_clone = history.clone();

  //* Create a callback function to respond to a click and handle it
  let click_handler = Callback::from(
    move |_| {
      //* Push a route into &quot;history_clone&quot;
      history_clone.push(Route::Home);
    }
  );

  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside router-two&quot;}&lt;/p&gt;
      &lt;button onclick={click_handler}&gt;{&quot;Go back to Home (Landing Page)&quot;}&lt;/button&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/router.rs'</pre>
<pre><code class="language-rust">// Create &quot;router.rs&quot;

use yew::prelude::*;
// You must use 'yew_router' crate prelude to be able to create public enum &quot;Route&quot; which must implement 'Routable'
use yew_router::prelude;

// use the components which are your routes, e.g, home.rs's Home component
use crate::components::router::home::Home;
use crate::components::router::route_one::RouteOne;
use crate::components::router::route_two::RouteTwo;

// Create a public enum &quot;Route&quot; to map your router links (i.e, routing by name)
// ..and &quot;Route&quot; must implement 'Routable', Clone, and 'PartialEq'
#[derive(Debug, Clone, PartialEq, Routable)]
pub enum Route {
  #[at(&quot;/&quot;)]
  LandingPage,
  #[at(&quot;/route-one&quot;)]
  RouteOne,
  #[at(&quot;/route-two&quot;)]
  RouteTwo,
}

// You need to create a function 'switch' to return proper component based on enum 'Route'
pub fn switch(route: &amp;Route) -&gt; Html {
  match route {
    Route::Home =&gt; html! { &lt;Home /&gt; },
    Route::RouteOne =&gt; html! { &lt;RouterOne /&gt; },
    Route::RouteTwo =&gt; html! { RouterTwo /&gt; },
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::LevelOneAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;
// You create a 'ContextProvider' at the place where you want to create a context data / object.
use yew::ContextProvider;
// You must use 'yew_router::prelude::*' in order to be able to use '&lt;Switch /&gt;' nested inside '&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;'
use yew_router::prelude::*;
// You must also use the &quot;switch&quot; function and &quot;Route&quot; enum inside &quot;yew_project_name/src/router.rs&quot;
use crate::router::{Router, switch};

pub mod components;
// &quot;router&quot; is a Rust file not a dir, unlike &quot;components&quot;
pub mod router;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

// &quot;ContextData&quot; will be used as a context object
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  let context_data_as_state = use_state(ContextData::default); // or 'use_state( || ContextData::default() ) '

  let first_run = use_state( || true);

  use_effect(
    move || {
      if *first_run {
        first_run.set(false);
      }
      || {} // Note that you could destroy/drop data inside this closure as well
    }
  );

  let on_submit_callback_property_receipient = Callback::from(
    |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = recieved_states_data.state_one;
      context_data.context_data_two = received_states_data.state_two;
      context_data_as_state.set(context_data);
    }
  );

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;p&gt;
          {&quot;ContextProvider demo code mini-project&quot;}
        &lt;/p&gt;

        &lt;LevelOneAComponent1 prop_one=&quot;hi&quot; /&gt;

        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            prop_on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
          {
            // Time to use 'BrowserRouter'. IMPORTANT: There is no way to pass properties into a Yew router, i.e 'BrowserRouter',
            // ..but.. you can use a Context as a proxy to pass data. Mind you every sibling component of the 'BrowserRouter' would also have access
            // ..to the data as well which may be undesireable.
            // Also, imagine sibling component &quot;LevelOneAComponent1&quot; plausibly being used as a nav-menu component ;-)
            // &quot;Route&quot; here is an enum, &quot;switch&quot; is a function which matches a &quot;Route&quot; variant to an actual route component.
          }
          &lt;BrowserRouter&gt;
            &lt;Switch&lt;Route&gt;
              render={Switch::render{switch}}
            /&gt;
          &lt;BrowserRouter&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="struct-component---creating-a-component-from-a-struct"><a class="header" href="#struct-component---creating-a-component-from-a-struct">Struct Component - creating a component from a struct</a></h2>
<p>You may want to jump to file: <span style="font-size: 14px;">yew_project_name/src/components/struct_based_components/struct_component_one.rs&quot;</span> for a quick look!</p>
<pre>New DIR "yew_project_name::src::components::struct_based_components" created</pre>
<pre>File "yew_project_name::src::components::struct_based_components::struct_component_one" will be used for the demonstration</pre>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
     |-routes
      |-mod.rs
      |-home.rs
      |-route_one.rs
      |-route_two.rs
     |-struct_based_components
      |-struct_component_one.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-router.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
yew-router = &quot;0.16.0&quot; </p>
<h1 id="-you-need-to-depend-on-yew-router-2"><a class="header" href="#-you-need-to-depend-on-yew-router-2">//* You need to depend on yew-router</a></h1>
</pre>
</code>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
// Expose newly created &quot;routes&quot; DIR
pub mod routes;
//* Expose newly created &quot;struct_based_components&quot; DIR
pub mod struct_based_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/mod.rs'</pre>
<pre><code class="language-rust">//* Expose file 'yew_project_name::src::components::struct_based_components::struct_component_one;
pub mod struct_component_one;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[pderive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  let states_data_as_state = use_state( || StatesData::default() );

  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); // This component will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // &quot;on_submit_callback_property&quot; is a Callback' type property
  let on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // To be .deref() and cloned later
  let states_data_as_state_clone = states_data_as_state.clone();

  // The callback function here is sensitive to an 'onsubmit' event, which causes it do send (emit) data up to its parent
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      on_submit_callback_property_clone.emit(states_data);

    }
  );

  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      {
        // Time to use context data trickled down from parent component
        //..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/mod.rs'</pre>
<pre><code class="language-rust">pub mod home.rs;
pub mod route_one.rs;
pub mod route_two.rs;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/home.rs'</pre>
<pre><code class="language-rust">// Create Home component

use yew::prelude::*;

// 'Since Link is inside 'yew_router::prelude::*', you must use it
use yew_router::prelude::*;
// You must also use the actual &quot;Route&quot; enum which Link would wrap around
use crate::router::Route;

#[function_component(Home)]
pub fn home() -&gt; Html {
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside the landing homepage!&quot;}&lt;/p&gt;
      {
        // Time to make a Link to another component without refreshing the page
      }
      &lt;div&gt;
        &lt;Link&lt;Route&gt;
          to={Route::RouteOne}&gt;{ &quot;Go to 'RouteOne' with no page refresh&quot; }
        &lt;/Link&lt;Route&gt;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/router_one.rs'</pre>
<pre><code class="language-rust">// Create RouterOne component

use yew::prelude::*;

#[function_component(RouterOne)]
pub fn router_one() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-one&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/route_two.rs'</pre>
<pre><code class="language-rust">// Create RouterTwo component

use yew::prelude::*;
// In order to apply 'use_history', you need to use 'yew_router::prelude::*;'
// ..and 'use_history' itself
use yew_router::{prelude::*, history};

#[function_component(RouterTwo)]
pub fn router_two() -&gt; Html {

  // Time to apply 'use_history'
  let history = use_history().unwrap();

  // Clone the applied history in cas you may use &quot;history&quot; multiple times
  let history_clone = history.clone();

  // Create a callback function to respond to a click and handle it
  let click_handler = Callback::from(
    move |_| {
      // Push a route into &quot;history_clone&quot;
      history_clone.push(Route::Home);
    }
  );

  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside router-two&quot;}&lt;/p&gt;
      &lt;button onclick={click_handler}&gt;{&quot;Go back to Home (Landing Page)&quot;}&lt;/button&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/router.rs'</pre>
<pre><code class="language-rust">// Create &quot;router.rs&quot;

use yew::prelude::*;
// You must use 'yew_router' crate prelude to be able to create public enum &quot;Route&quot; which must implement 'Routable'
use yew_router::prelude;

// use the components which are your routes, e.g, home.rs's Home component
use crate::components::router::home::Home;
use crate::components::router::route_one::RouteOne;
use crate::components::router::route_two::RouteTwo;

// Create a public enum &quot;Route&quot; to map your router links (i.e, routing by name)
// ..and &quot;Route&quot; must implement 'Routable', Clone, and 'PartialEq'
#[derive(Debug, Clone, PartialEq, Routable)]
pub enum Route {
  #[at(&quot;/&quot;)]
  LandingPage,
  #[at(&quot;/route-one&quot;)]
  RouteOne,
  #[at(&quot;/route-two&quot;)]
  RouteTwo,
}

// You need to create a function 'switch' to return proper component based on enum 'Route'
pub fn switch(route: &amp;Route) -&gt; Html {
  match route {
    Route::Home =&gt; html! { &lt;Home /&gt; },
    Route::RouteOne =&gt; html! { &lt;RouterOne /&gt; },
    Route::RouteTwo =&gt; html! { RouterTwo /&gt; },
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/struct_component_one.rs'</pre>
<pre><code class="language-rust">//* Use essential files/libraries
use yew::prelude::*;

//* Because of my interest in embedding another component inside the HTML rendered from this component,
//* ..I have decided to use &quot;yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs&quot; component
use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

//* Creation of a struct-based component called &quot;StructComponentOne&quot;
pub struct StructComponentOne {
  pub content_one: String,
}

//* You must implement 'Component' for your struct component
impl Component for StructComponentOne {

  type Message = (); //* empty tuple/unit for now
  type Properties = (); //* empty tuple/unit for now

  //* Constructs the component
  fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self {
      content_one: &quot;Hey, I am of StructComponentOne! Just like a state, without the need for a 'use_state' :-)&quot;.to_onwed(),
    }
  }

  //* This function is what renders 'HTML' or one or components to the screen
  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      &lt;div&gt;
        &lt;SubComponentsAComponent1 prop_one={&quot;StructComponentOne has rendered SubComponentsAComponent1!&quot;} /&gt;
        &lt;p&gt;{&quot;I, StructComponentOne, has the followiing content_one: &quot;}{&amp;self.content_one}&lt;/p&gt;
      &lt;/div&gt;
    }
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;

//* Use &quot;crate::components::struct_based_components::struct_component_one::StructComponentOne&quot;
use crate::components::struct_based_components::struct_component_one::StructComponentOne;

// Use &quot;switch&quot; function and &quot;Route&quot; enum inside &quot;yew_project_name/src/router.rs&quot;
use crate::router::{Router, switch};

// You create a 'ContextProvider' at the place where you want to create a context data / object.
use yew::ContextProvider;

// You must use 'yew_router::prelude::*' in order to be able to use '&lt;Switch /&gt;' nested inside '&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;'
use yew_router::prelude::*;

//* DIR &quot;struct_based_components&quot; can be found here
pub mod components;

// &quot;router&quot; is a Rust file not a dir, unlike &quot;components&quot;
pub mod router;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

// &quot;ContextData&quot; will be used as a context object
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  let context_data_as_state = use_state(ContextData::default); // or 'use_state( || ContextData::default() ) '

  let first_run = use_state( || true);

  use_effect(
    move || {
      if *first_run {
        first_run.set(false);
      }
      || {} // Note that you could destroy/drop data inside this closure as well
    }
  );

  let on_submit_callback_property_receipient = Callback::from(
    |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = recieved_states_data.state_one;
      context_data.context_data_two = received_states_data.state_two;
      context_data_as_state.set(context_data);
    }
  );

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;

        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            prop_on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
          {
            // Time to use 'BrowserRouter'. IMPORTANT: There is no way to pass properties into a Yew router, i.e 'BrowserRouter',
            // ..but.. you can use a Context as a proxy to pass data. Mind you every sibling component of the 'BrowserRouter' would also have access
            // ..to the data as well which may be undesireable.
            // Also, imagine sibling component &quot;SubComponentsAComponent1&quot; plausibly being used as a nav-menu component ;-)
            // &quot;Route&quot; here is an enum, &quot;switch&quot; is a function which matches a &quot;Route&quot; variant to an actual route component.
          }
          &lt;BrowserRouter&gt;
            &lt;Switch&lt;Route&gt;
              render={Switch::render{switch}}
            /&gt;
          &lt;BrowserRouter&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

        {
          //* Time to apply StructComponentOne
        }
        &lt;StructComponentOne /&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="styling-a-struct-component"><a class="header" href="#styling-a-struct-component">Styling a struct component</a></h2>
<p>You may want to jump to file: &quot;yew_project_name/src/components/struct_based_components/struct_component_one.rs&quot; for a quick look!</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
     |-routes
      |-mod.rs
      |-home.rs
      |-route_one.rs
      |-route_two.rs
     |-struct_based_components
      |-struct_component_one.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-router.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
yew-router = &quot;0.16.0&quot; </p>
<h1 id="-you-need-to-depend-on-yew-router-3"><a class="header" href="#-you-need-to-depend-on-yew-router-3">//* You need to depend on yew-router</a></h1>
</pre>
</code>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
// Expose newly created &quot;routes&quot; DIR
pub mod routes;
//* Expose newly created &quot;struct_based_components&quot; DIR
pub mod struct_based_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/mod.rs'</pre>
<pre><code class="language-rust">//* Expose file 'yew_project_name::src::components::struct_based_components::struct_component_one;
pub mod struct_component_one;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  let states_data_as_state = use_state( || StatesData::default() );

  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); // This component will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // &quot;on_submit_callback_property&quot; is a Callback' type property
  let on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // To be .deref() and cloned later
  let states_data_as_state_clone = states_data_as_state.clone();

  // The callback function here is sensitive to an 'onsubmit' event, which causes it do send (emit) data up to its parent
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      on_submit_callback_property_clone.emit(states_data);

    }
  );

  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      {
        // Time to use context data trickled down from parent component
        //..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/mod.rs</pre>
<pre><code class="language-rust">pub mod home.rs;
pub mod route_one.rs;
pub mod route_two.rs;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/home.rs'</pre>
<pre><code class="language-rust">// Create Home component

use yew::prelude::*;

// 'Since Link is inside 'yew_router::prelude::*', you must use it
use yew_router::prelude::*;
// You must also use the actual &quot;Route&quot; enum which Link would wrap around
use crate::router::Route;

#[function_component(Home)]
pub fn home() -&gt; Html {
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside the landing homepage!&quot;}&lt;/p&gt;
      {
        // Time to make a Link to another component without refreshing the page
      }
      &lt;div&gt;
        &lt;Link&lt;Route&gt;
          to={Route::RouteOne}&gt;{ &quot;Go to 'RouteOne' with no page refresh&quot; }
        &lt;/Link&lt;Route&gt;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/router_one.rs'</pre>
<pre><code class="language-rust">// Create RouterOne component

use yew::prelude::*;

#[function_component(RouterOne)]
pub fn router_one() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-one&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/route_two.rs'</pre>
<pre><code class="language-rust">// Create RouterTwo component

use yew::prelude::*;
// In order to apply 'use_history', you need to use 'yew_router::prelude::*;'
// ..and 'use_history' itself
use yew_router::{prelude::*, history};

#[function_component(RouterTwo)]
pub fn router_two() -&gt; Html {

  // Time to apply 'use_history'
  let history = use_history().unwrap();

  // Clone the applied history in cas you may use &quot;history&quot; multiple times
  let history_clone = history.clone();

  // Create a callback function to respond to a click and handle it
  let click_handler = Callback::from(
    move |_| {
      // Push a route into &quot;history_clone&quot;
      history_clone.push(Route::Home);
    }
  );

  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside router-two&quot;}&lt;/p&gt;
      &lt;button onclick={click_handler}&gt;{&quot;Go back to Home (Landing Page)&quot;}&lt;/button&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/router.rs'</pre>
<pre><code class="language-rust">// Create &quot;router.rs&quot;

use yew::prelude::*;
// You must use 'yew_router' crate prelude to be able to create public enum &quot;Route&quot; which must implement 'Routable'
use yew_router::prelude;

// use the components which are your routes, e.g, home.rs's Home component
use crate::components::router::home::Home;
use crate::components::router::route_one::RouteOne;
use crate::components::router::route_two::RouteTwo;

// Create a public enum &quot;Route&quot; to map your router links (i.e, routing by name)
// ..and &quot;Route&quot; must implement 'Routable', Clone, and 'PartialEq'
#[derive(Debug, Clone, PartialEq, Routable)]
pub enum Route {
  #[at(&quot;/&quot;)]
  LandingPage,
  #[at(&quot;/route-one&quot;)]
  RouteOne,
  #[at(&quot;/route-two&quot;)]
  RouteTwo,
}

// You need to create a function 'switch' to return proper component based on enum 'Route'
pub fn switch(route: &amp;Route) -&gt; Html {
  match route {
    Route::Home =&gt; html! { &lt;Home /&gt; },
    Route::RouteOne =&gt; html! { &lt;RouterOne /&gt; },
    Route::RouteTwo =&gt; html! { RouterTwo /&gt; },
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/struct_component_one.rs'</pre>
<pre><code class="language-rust">//* StructComponentOne

// Use essential files/libraries
use yew::prelude::*;

//* You need to use stylist's 'style' and 'Style' to style a struct component too
use stylist::{style, Style};

use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

// Creation of a struct-based component called &quot;StructComponentOne&quot;
pub struct StructComponentOne {
  pub content_one: String,
  //* Your style has to be a property of your struct component
  struct_component_style: Style,
}

//* You can impl StructComponentOne such that it has a function which returns a 'style!' string
impl StructComponentOne {

  fn styler() -&gt; Style {
    style!(
      r#&quot;
        color: yellow;

        .p-class: {
          color: brown;
        }

      &quot;#
    ).unwrap();
  }
}

// Implement 'Component' for your struct component
impl Component for StructComponentOne {

  type Message = (); //* empty tuple/unit for now
  type Properties = (); //* empty tuple/unit for now

  //* Constructs the component
  fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self {
      content_one: &quot;Hey, I am of StructComponentOne! Just like a state, without the need for a 'use_state' :-)&quot;.to_onwed(),
      //* Remember to assign a value to &quot;struct_component_style&quot; too
      struct_component_style: Self::styler(),
    }
  }

  // This function is what renders 'HTML' or one or components to the screen
  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      {
        //* Apply a clone of the style property of the struct component to any element or component's class value
        //* ..in order for style to take effect
      }
      &lt;div class={self.struct_component_style.clone()}&gt;
        &lt;SubComponentsAComponent1 prop_one={&quot;StructComponentOne has rendered SubComponentsAComponent1!&quot;} /&gt;
        &lt;p class=&quot;p-class&quot;&gt;{&quot;I, StructComponentOne, has the followiing content_one: &quot;}{&amp;self.content_one}&lt;/p&gt;
      &lt;/div&gt;
    }
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;

// Use &quot;crate::components::struct_based_components::struct_component_one::StructComponentOne&quot;
use crate::components::struct_based_components::struct_component_one::StructComponentOne;

// Use &quot;switch&quot; function and &quot;Route&quot; enum inside &quot;yew_project_name/src/router.rs&quot;
use crate::router::{Router, switch};

// You create a 'ContextProvider' at the place where you want to create a context data / object.
use yew::ContextProvider;

// You must use 'yew_router::prelude::*' in order to be able to use '&lt;Switch /&gt;' nested inside '&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;'
use yew_router::prelude::*;

// DIR &quot;struct_based_components&quot; can be found here
pub mod components;

// &quot;router&quot; is a Rust file not a dir, unlike &quot;components&quot;
pub mod router;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

// &quot;ContextData&quot; will be used as a context object
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  let context_data_as_state = use_state(ContextData::default); // or 'use_state( || ContextData::default() ) '

  let first_run = use_state( || true);

  use_effect(
    move || {
      if *first_run {
        first_run.set(false);
      }
      || {} // Note that you could destroy/drop data inside this closure as well
    }
  );

  let on_submit_callback_property_receipient = Callback::from(
    |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = recieved_states_data.state_one;
      context_data.context_data_two = received_states_data.state_two;
      context_data_as_state.set(context_data);
    }
  );

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;

        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            prop_on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
          {
            // Time to use 'BrowserRouter'. IMPORTANT: There is no way to pass properties into a Yew router, i.e 'BrowserRouter',
            // ..but.. you can use a Context as a proxy to pass data. Mind you every sibling component of the 'BrowserRouter' would also have access
            // ..to the data as well which may be undesireable.
            // Also, imagine sibling component &quot;SubComponentsAComponent1&quot; plausibly being used as a nav-menu component ;-)
            // &quot;Route&quot; here is an enum, &quot;switch&quot; is a function which matches a &quot;Route&quot; variant to an actual route component.
          }
          &lt;BrowserRouter&gt;
            &lt;Switch&lt;Route&gt;
              render={Switch::render{switch}}
            /&gt;
          &lt;BrowserRouter&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

        {
          // Time to apply StructComponentOne
        }
        &lt;StructComponentOne /&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="passing-a-prop-object-to-a-struct-component"><a class="header" href="#passing-a-prop-object-to-a-struct-component">Passing a prop object to a struct component</a></h2>
<p>You may want to jump to file: &quot;yew_project_name/src/components/struct_based_components/struct_component_one.rs&quot; for a quick look!</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component.rs
      |-form_button_component.rs
      |-form_assembly_component.rs
      |-mod.rs
     |-routes
      |-mod.rs
      |-home.rs
      |-route_one.rs
      |-route_two.rs
     |-struct_based_components
      |-struct_component_one.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-router.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
// Expose newly created &quot;routes&quot; DIR
pub mod routes;
//* Expose newly created &quot;struct_based_components&quot; DIR
pub mod struct_based_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/mod.rs'</pre>
<pre><code class="language-rust">//* Expose file 'yew_project_name::src::components::struct_based_components::struct_component_one;
pub mod struct_component_one;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component::FormInputComponent;
use crate::components::form_components::form_button_component::FormButtonComponent;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  let states_data_as_state = use_state( || StatesData::default() );

  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); // This component will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // &quot;on_submit_callback_property&quot; is a Callback' type property
  let on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // To be .deref() and cloned later
  let states_data_as_state_clone = states_data_as_state.clone();

  // The callback function here is sensitive to an 'onsubmit' event, which causes it do send (emit) data up to its parent
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      on_submit_callback_property_clone.emit(states_data);

    }
  );

  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      {
        // Time to use context data trickled down from parent component
        //..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/mod.rs'</pre>
<pre><code class="language-rust">pub mod home.rs;
pub mod route_one.rs;
pub mod route_two.rs;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/home.rs'</pre>
<pre><code class="language-rust">// Create Home component

use yew::prelude::*;

// 'Since Link is inside 'yew_router::prelude::*', you must use it
use yew_router::prelude::*;
// You must also use the actual &quot;Route&quot; enum which Link would wrap around
use crate::router::Route;

#[function_component(Home)]
pub fn home() -&gt; Html {
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside the landing homepage!&quot;}&lt;/p&gt;
      {
        // Time to make a Link to another component without refreshing the page
      }
      &lt;div&gt;
        &lt;Link&lt;Route&gt;
          to={Route::RouteOne}&gt;{ &quot;Go to 'RouteOne' with no page refresh&quot; }
        &lt;/Link&lt;Route&gt;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/router_one.rs'</pre>
<pre><code class="language-rust">// Create RouterOne component

use yew::prelude::*;

#[function_component(RouterOne)]
pub fn router_one() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-one&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/route_two.rs'</pre>
<pre><code class="language-rust">// Create RouterTwo component

use yew::prelude::*;
// In order to apply 'use_history', you need to use 'yew_router::prelude::*;'
// ..and 'use_history' itself
use yew_router::{prelude::*, history};

#[function_component(RouterTwo)]
pub fn router_two() -&gt; Html {

  // Time to apply 'use_history'
  let history = use_history().unwrap();

  // Clone the applied history in cas you may use &quot;history&quot; multiple times
  let history_clone = history.clone();

  // Create a callback function to respond to a click and handle it
  let click_handler = Callback::from(
    move |_| {
      // Push a route into &quot;history_clone&quot;
      history_clone.push(Route::Home);
    }
  );

  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside router-two&quot;}&lt;/p&gt;
      &lt;button onclick={click_handler}&gt;{&quot;Go back to Home (Landing Page)&quot;}&lt;/button&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/router.rs'</pre>
<pre><code class="language-rust">// Create &quot;router.rs&quot;

use yew::prelude::*;
// You must use 'yew_router' crate prelude to be able to create public enum &quot;Route&quot; which must implement 'Routable'
use yew_router::prelude;

// use the components which are your routes, e.g, home.rs's Home component
use crate::components::router::home::Home;
use crate::components::router::route_one::RouteOne;
use crate::components::router::route_two::RouteTwo;

// Create a public enum &quot;Route&quot; to map your router links (i.e, routing by name)
// ..and &quot;Route&quot; must implement 'Routable', Clone, and 'PartialEq'
#[derive(Debug, Clone, PartialEq, Routable)]
pub enum Route {
  #[at(&quot;/&quot;)]
  LandingPage,
  #[at(&quot;/route-one&quot;)]
  RouteOne,
  #[at(&quot;/route-two&quot;)]
  RouteTwo,
}

// You need to create a function 'switch' to return proper component based on enum 'Route'
pub fn switch(route: &amp;Route) -&gt; Html {
  match route {
    Route::Home =&gt; html! { &lt;Home /&gt; },
    Route::RouteOne =&gt; html! { &lt;RouterOne /&gt; },
    Route::RouteTwo =&gt; html! { RouterTwo /&gt; },
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/struct_component_one.rs'</pre>
<pre><code class="language-rust">//* Demo code below. Take Note.

// Use essential files/libraries
use yew::prelude::*;

// You need to use stylist's 'style' and 'Style' to style a struct component too
use stylist::{style, Style};

use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

//* Create prop object (struct) that would be used in/with &quot;StructComponentOne&quot;
#[derive(Properties, PartialEq)]
pub struct StructComponentOneProp {
  pub prop_one: String,
}

// Creation of a struct-based component called &quot;StructComponentOne&quot;
pub struct StructComponentOne {
  pub content_one: String,
  // Your style has to be a property of your struct component
  struct_component_style: Style,
}

// You can impl StructComponentOne such that it has a function which returns a 'style!' string
impl StructComponentOne {

  fn styler() -&gt; Style {
    style!(
      r#&quot;
        color: yellow;

        .p-class: {
          color: brown;
        }

      &quot;#
    ).unwrap();
  }
}

// Implement 'Component' for your struct component
impl Component for StructComponentOne {

  type Message = (); //* empty tuple/unit for now
  //* Replace: type Properties = (); //* empty tuple/unit for now
  //* ..with:
  type Properties = StructComponentOneProp

  // Constructs the component
  fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self {

      content_one: &quot;Hey, I am of StructComponentOne! Just like a state, without the need for a 'use_state' :-)&quot;.to_onwed(),
      // Remember to assign a value to &quot;struct_component_style&quot; too
      struct_component_style: Self::styler(),

    }
  }

  // This function is what renders 'HTML' or one or components to the screen
  //* &quot;ctx&quot; is short for &quot;context&quot;
  //* You can access properties here via &quot;ctx&quot;
  fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      {
        // Apply a clone of the style property of the struct component to any element or component's class value
        // ..in order for style to take effect
      }
      &lt;div class={self.struct_component_style.clone()}&gt;
        &lt;SubComponentsAComponent1 prop_one={&quot;StructComponentOne has rendered SubComponentsAComponent1!&quot;} /&gt;
        {
          //* We'll be accessing property &quot;prop_one&quot; and make use of it here
          //* ..via a &quot;&amp;ctx.props().prop_one&quot;
        }
        &lt;p class=&quot;p-class&quot;&gt;{&quot;I, StructComponentOne, have a property &quot;prop_one&quot; in my prop object, with value: &quot;}{&amp;ctx.props().prop_one}&lt;/p&gt;
        &lt;p class=&quot;p-class&quot;&gt;{&quot;I, StructComponentOne, have the following content_one: &quot;}{&amp;self.content_one}&lt;/p&gt;
      &lt;/div&gt;
    }
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;

// Use &quot;crate::components::struct_based_components::struct_component_one::StructComponentOne&quot;
use crate::components::struct_based_components::struct_component_one::StructComponentOne;

// Use &quot;switch&quot; function and &quot;Route&quot; enum inside &quot;yew_project_name/src/router.rs&quot;
use crate::router::{Router, switch};

// You create a 'ContextProvider' at the place where you want to create a context data / object.
use yew::ContextProvider;

// You must use 'yew_router::prelude::*' in order to be able to use '&lt;Switch /&gt;' nested inside '&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;'
use yew_router::prelude::*;

// DIR &quot;struct_based_components&quot; can be found here
pub mod components;

// &quot;router&quot; is a Rust file not a dir, unlike &quot;components&quot;
pub mod router;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

// &quot;ContextData&quot; will be used as a context object
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  let context_data_as_state = use_state(ContextData::default); // or 'use_state( || ContextData::default() ) '

  let first_run = use_state( || true);

  use_effect(
    move || {
      if *first_run {
        first_run.set(false);
      }
      || {} // Note that you could destroy/drop data inside this closure as well
    }
  );

  let on_submit_callback_property_receipient = Callback::from(
    |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = recieved_states_data.state_one;
      context_data.context_data_two = received_states_data.state_two;
      context_data_as_state.set(context_data);
    }
  );

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;

        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            prop_on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
          {
            // Time to use 'BrowserRouter'. IMPORTANT: There is no way to pass properties into a Yew router, i.e 'BrowserRouter',
            // ..but.. you can use a Context as a proxy to pass data. Mind you every sibling component of the 'BrowserRouter' would also have access
            // ..to the data as well which may be undesireable.
            // Also, imagine sibling component &quot;SubComponentsAComponent1&quot; plausibly being used as a nav-menu component ;-)
            // &quot;Route&quot; here is an enum, &quot;switch&quot; is a function which matches a &quot;Route&quot; variant to an actual route component.
          }
          &lt;BrowserRouter&gt;
            &lt;Switch&lt;Route&gt;
              render={Switch::render{switch}}
            /&gt;
          &lt;BrowserRouter&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

        {
          //* Time to apply StructComponentOne
          //* You must now provide a value for every &quot;StructComponentOne&quot; prop-object-properties
          //* ...which in this case is just one called &quot;prop_one&quot;
        }
        &lt;StructComponentOne prop_one={&quot;StructComponentOne's prop_one property acknowledged!&quot;.to_owned()} /&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="struct-components-life-cycle-methods"><a class="header" href="#struct-components-life-cycle-methods">Struct Components life cycle methods</a></h2>
<p>You may want to jump to file: <span style="font-size: 14px;">&quot;yew_project_name/src/components/struct_based_components/struct_component_one.rs&quot;</span> for a quick look!</p>
<pre>New DIR "yew_project_name::src::components::struct_based_components" created</pre>
<pre>File "yew_project_name::src::components::struct_based_components::struct_component_one" will be used for the demonstration</pre>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
     |-routes
      |-mod.rs
      |-home.rs
      |-route_one.rs
      |-route_two.rs
     |-struct_based_components
      |-struct_component_one.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-router.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<p>// INSIDE 'Cargo.toml'
<code></p>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
  
[dependencies]
yew = "0.19.3"
stylist = {version = "0.10.8" features = ["yew"]}
wasm-bindgen = "0.2.79"
web-sys = { version = "0.3.56", features = ["HtmlInputElement] }
gloo = "0.6.1"
yew-router = "0.16.0"
</pre>
</code>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
// Expose newly created &quot;routes&quot; DIR
pub mod routes;
//* Expose newly created &quot;struct_based_components&quot; DIR
pub mod struct_based_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/mod.rs'</pre>
<pre><code class="language-rust">//* Expose file 'yew_project_name::src::components::struct_based_components::struct_component_one;
pub mod struct_component_one;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<p></pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component.rs'</pre></p>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component;
use crate::components::form_components::form_button_component;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  let states_data_as_state = use_state( || StatesData::default() );

  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); // This component will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // &quot;on_submit_callback_property&quot; is a Callback' type property
  let on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // To be .deref() and cloned later
  let states_data_as_state_clone = states_data_as_state.clone();

  // The callback function here is sensitive to an 'onsubmit' event, which causes it do send (emit) data up to its parent
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      on_submit_callback_property_clone.emit(states_data);

    }
  );

  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      {
        // Time to use context data trickled down from parent component
        //..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/mod.rs'</pre>
<pre><code class="language-rust">pub mod home.rs;
pub mod route_one.rs;
pub mod route_two.rs;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/home.rs'</pre>
<pre><code class="language-rust">// Create Home component

use yew::prelude::*;

// 'Since Link is inside 'yew_router::prelude::*', you must use it
use yew_router::prelude::*;
// You must also use the actual &quot;Route&quot; enum which Link would wrap around
use crate::router::Route;

#[function_component(Home)]
pub fn home() -&gt; Html {
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside the landing homepage!&quot;}&lt;/p&gt;
      {
        // Time to make a Link to another component without refreshing the page
      }
      &lt;div&gt;
        &lt;Link&lt;Route&gt;
          to={Route::RouteOne}&gt;{ &quot;Go to 'RouteOne' with no page refresh&quot; }
        &lt;/Link&lt;Route&gt;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/router_one.rs'</pre>
<pre><code class="language-rust">// Create RouterOne component

use yew::prelude::*;

#[function_component(RouterOne)]
pub fn router_one() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-one&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/route_two.rs'</pre>
<pre><code class="language-rust">// Create RouterTwo component

use yew::prelude::*;
// In order to apply 'use_history', you need to use 'yew_router::prelude::*;'
// ..and 'use_history' itself
use yew_router::{prelude::*, history};

#[function_component(RouterTwo)]
pub fn router_two() -&gt; Html {

  // Time to apply 'use_history'
  let history = use_history().unwrap();

  // Clone the applied history in cas you may use &quot;history&quot; multiple times
  let history_clone = history.clone();

  // Create a callback function to respond to a click and handle it
  let click_handler = Callback::from(
    move |_| {
      // Push a route into &quot;history_clone&quot;
      history_clone.push(Route::Home);
    }
  );

  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside router-two&quot;}&lt;/p&gt;
      &lt;button onclick={click_handler}&gt;{&quot;Go back to Home (Landing Page)&quot;}&lt;/button&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/router.rs'</pre>
<pre><code class="language-rust">// Create &quot;router.rs&quot;

use yew::prelude::*;
// You must use 'yew_router' crate prelude to be able to create public enum &quot;Route&quot; which must implement 'Routable'
use yew_router::prelude;

// use the components which are your routes, e.g, home.rs's Home component
use crate::components::router::home::Home;
use crate::components::router::route_one::RouteOne;
use crate::components::router::route_two::RouteTwo;

// Create a public enum &quot;Route&quot; to map your router links (i.e, routing by name)
// ..and &quot;Route&quot; must implement 'Routable', Clone, and 'PartialEq'
#[derive(Debug, Clone, PartialEq, Routable)]
pub enum Route {
  #[at(&quot;/&quot;)]
  LandingPage,
  #[at(&quot;/route-one&quot;)]
  RouteOne,
  #[at(&quot;/route-two&quot;)]
  RouteTwo,
}

// You need to create a function 'switch' to return proper component based on enum 'Route'
pub fn switch(route: &amp;Route) -&gt; Html {
  match route {
    Route::Home =&gt; html! { &lt;Home /&gt; },
    Route::RouteOne =&gt; html! { &lt;RouterOne /&gt; },
    Route::RouteTwo =&gt; html! { RouterTwo /&gt; },
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/struct_component_one.rs'</pre>
<pre><code class="language-rust">//* Use essential files/libraries
use yew::prelude::*;

//* Because of my interest in embedding another component inside the HTML rendered from this component,
//* ..I have decided to use &quot;yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs&quot; component
use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

//* Creation of a struct-based component called &quot;StructComponentOne&quot;
pub struct StructComponentOne {
  pub content_one: String,
}

//* You must implement 'Component' for your struct component
impl Component for StructComponentOne {

  type Message = (); //* empty tuple/unit for now
  type Properties = (); //* empty tuple/unit for now

  //* Constructs the component
  //* Required for every struct component
  fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self {
      content_one: &quot;Hey, I am of StructComponentOne! Just like a state, without the need for a 'use_state' :-)&quot;.to_onwed(),
    }
  }

  //* This function is what renders 'HTML' or one or components to the screen
  //* Required for every struct component
  fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      &lt;div&gt;
        &lt;SubComponentsAComponent1 prop_one={&quot;StructComponentOne has rendered SubComponentsAComponent1!&quot;} /&gt;
        &lt;p&gt;{&quot;I, StructComponentOne, has the followiing content_one: &quot;}{&amp;self.content_one}&lt;/p&gt;
      &lt;/div&gt;
    }
  }

  //* Now pay attention to the actual lifecycle methods:
  //* - update
  //* - changed
  //* - rendered
  //* - destroy

  //* update
  //* Activated whenever a message is updated in a struct
  fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
    // false tells Yew not to do a rerender
    false
  }

  //* changed
  //* Activated when a property of a struct is assigned a new value
  fn changed(&amp;mut self, ctx: &amp;Context&lt;Self&gt;) -&gt; bool {
    // true means do the rerender
    true
  }

  //* rendered
  //* It tells you whether or not it is the first render via 'first_render' bool,
  //* ..and then inside the function you can do anything you want based on this boolean value
  //* ..maybe even update internal state
  fn rendered(
    &amp;mut self,
    ctx: &amp;Context&lt;Self&gt;,
    first_render: bool
  ) {
    // --
  }

  //* destroy
  //* Do something when the component is being destroyed and all memory is being collected to be deallocated
  fn destroy(&amp;mut self, ctx: &amp;Context&lt;Self&gt;) {
    // --
  }

  //* You will realize that you may not find use cases for 'destroy', 'rendered' and 'changed'

} //* end of &quot;impl Component for StructComponentOne&quot;
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;

//* Use &quot;crate::components::struct_based_components::struct_component_one::StructComponentOne&quot;
use crate::components::struct_based_components::struct_component_one::StructComponentOne;

// Use &quot;switch&quot; function and &quot;Route&quot; enum inside &quot;yew_project_name/src/router.rs&quot;
use crate::router::{Router, switch};

// You create a 'ContextProvider' at the place where you want to create a context data / object.
use yew::ContextProvider;

// You must use 'yew_router::prelude::*' in order to be able to use '&lt;Switch /&gt;' nested inside '&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;'
use yew_router::prelude::*;

//* DIR &quot;struct_based_components&quot; can be found here
pub mod components;

// &quot;router&quot; is a Rust file not a dir, unlike &quot;components&quot;
pub mod router;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

// &quot;ContextData&quot; will be used as a context object
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  let context_data_as_state = use_state(ContextData::default); // or 'use_state( || ContextData::default() ) '

  let first_run = use_state( || true);

  use_effect(
    move || {
      if *first_run {
        first_run.set(false);
      }
      || {} // Note that you could destroy/drop data inside this closure as well
    }
  );

  let on_submit_callback_property_receipient = Callback::from(
    |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = recieved_states_data.state_one;
      context_data.context_data_two = received_states_data.state_two;
      context_data_as_state.set(context_data);
    }
  );

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;

        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            prop_on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
          {
            // Time to use 'BrowserRouter'. IMPORTANT: There is no way to pass properties into a Yew router, i.e 'BrowserRouter',
            // ..but.. you can use a Context as a proxy to pass data. Mind you every sibling component of the 'BrowserRouter' would also have access
            // ..to the data as well which may be undesireable.
            // Also, imagine sibling component &quot;SubComponentsAComponent1&quot; plausibly being used as a nav-menu component ;-)
            // &quot;Route&quot; here is an enum, &quot;switch&quot; is a function which matches a &quot;Route&quot; variant to an actual route component.
          }
          &lt;BrowserRouter&gt;
            &lt;Switch&lt;Route&gt;
              render={Switch::render{switch}}
            /&gt;
          &lt;BrowserRouter&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

        {
          //* Time to apply StructComponentOne
        }
        &lt;StructComponentOne /&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="struct-components---messages"><a class="header" href="#struct-components---messages">Struct Components - messages</a></h2>
<p>Handle data sent back and forth between a struct's lifecycle methods.</p>
<pre>You may want to jump to file: "yew_project_name/src/components/struct_based_components/struct_component_two.rs" for a quick look!</pre>
<p><prpe>New file &quot;yew_project_name/src/components/struct_based_components/struct_component_two.rs&quot; created.</pre></p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sub_components_a
      |-sub_components_a_component_1.rs
     |-form_components
      |-form_input_component
      |-form_button_component
      |-form_assembly_component
      |-mod.rs
     |-routes
      |-mod.rs
      |-home.rs
      |-route_one.rs
      |-route_two.rs
     |-struct_based_components
      |-struct_component_one.rs
      |-struct_component_two.rs
      |-mod.rs
    |-lib.rs
    |-main.rs
    |-router.rs
    |-main.css
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version = &quot;0.3.56&quot;, features = [&quot;HtmlInputElement] }
gloo = &quot;0.6.1&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a;
pub mod form_components;
// Expose newly created &quot;routes&quot; DIR
pub mod routes;
//* Expose newly created &quot;struct_based_components&quot; DIR
pub mod struct_based_components;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod form_input_component;
pub mod form_button_component;
pub mod form_assembler_component;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/mod.rs'</pre>
<pre><code class="language-rust">pub mod struct_component_one;
//* Expose file 'yew_project_name::src::components::struct_based_components::struct_component_two;
pub mod struct_component_two;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/mod.rs'</pre>
<pre><code class="language-rust">pub mod sub_components_a_component_1;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;

<span class="boring">derive[(Properties, PartialEq)]
</span>pub struct Props {
  pub prop_one: String,
  pub prop_two: Option&lt;String&gt;,
}

#[function_component(SubComponentsAComponent1)]
pub fn sub_components_a_component_1(prop: &amp;Prop) -&gt; Html {

  html! {
    &lt;div&gt;

      &lt;p&gt;{&quot;Hi! I am from component file 'src/components/sub_components_a/sub_components_a_component_1.rs'&quot;}&lt;/p&gt;
      &lt;p&gt;{&quot;...and I was passed property/properties: &quot;} {&amp;prop.prop_one.to_onwed()}&lt;/p&gt;

    &lt;/div&gt;
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_input_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::HtmlInputElement;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input: String,
  pub handle_call_to_action: Callback&lt;String&gt;,
}

#[function_component(FormInputComponent)]
fn form_input_component(props: &amp;Props) -&gt; Html {

  let handle_call_to_action_clone = props.handle_call_to_action.clone();

  let call_to_action = Callback::from(

    move | input_event | {
      let input_event_target = input_event.target().unwrap();
      let current_input_text = input_event_target.unchecked_into::&lt;HtmlInputElement&gt;();
      handle_call_to_action_clone.emit(current_input_text.value());
    }

  );

  html! {
    &lt;input type=&quot;text&quot; name={props.input.clone()} onchange={call_to_action} placeholder={props.input.clone} /&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_button_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub button_one: String,
}

#[function_component(FormButtonComponent)]
fn form_button_component(props: &amp;Props) -&gt; Html {

  html! {
    &lt;button&gt;{&amp;props.button_one}&lt;/button&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/form_components/form_assembler_component'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use crate::components::form_components::form_input_component;
use crate::components::form_components::form_button_component;

#[derive(Properties, PartialEq)]
pub struct Props {
  pub input_one_value: String,
  pub input_two_value: String,
  pub button_name: String,
  pub on_submit_callback_property: Callback&lt;StatesData&gt;
}

// A struct &quot;StatesData&quot; to be managed as a state
#[derive(Default, Clone)]
pub struct StatesData {
  pub state_one: String,
  pub state_two: String,
}

#[function_component(FormAssemblerComponent)]
pub fn function_assembler(props: &amp;Props) -&gt; Html {

  let states_data_as_state = use_state( || StatesData::default() );

  let use_context_for_context_data = use_context::&lt;ContextData&gt;(); // This component will automatically now have access to &quot;ContextData&quot; because you opted in for access.

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_callback_receipient&quot;

  let input_1_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_one = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  let states_data_as_state_clone = states_data_as_state.clone(); // For &quot;input_2_callback_receipient&quot;

  let input_2_callback_receipient = Callback::from(
    move |received_current_input_text| {

      let mut states_data = states_data_as_state_clone.deref().clone();
      states_data.state_two = received_current_input_text;
      states_data_as_state_clone.set(states_data);

    }
  );

  // &quot;on_submit_callback_property&quot; is a Callback' type property
  let on_submit_callback_property_clone = props.on_submit_callback_property.clone();

  // To be .deref() and cloned later
  let states_data_as_state_clone = states_data_as_state.clone();

  // The callback function here is sensitive to an 'onsubmit' event, which causes it do send (emit) data up to its parent
  let on_submit_callback = Callback::from(

    move |onsubmit_event_trigger: FocusEvent| {

      onsubmit_event_trigger.preventDefault();
      let states_data = states_data_as_state_clone.deref().clone();
      // emit &quot;states_data&quot;
      on_submit_callback_property_clone.emit(states_data);

    }
  );

  html! {
    &lt;form onsubmit={on_submit_callback}&gt;

      &lt;FormInputComponent input={&amp;props.input_one_value.clone()} handle_call_back_action={input_1_callback_receipient} /&gt;
      &lt;FormInputComponent input={&amp;props.input_two_value.clone()} handle_call_back_action={input_2_callback_receipient} /&gt;
      &lt;FormButtonComponent button_one={&amp;props.button_name.clone()} /&gt;

      {
        // Time to use context data trickled down from parent component
        //..and remember calling 'unwrap_or_default()' on &quot;use_context_for_context_data&quot; 's clone
      }
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_one is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_one}
      &lt;/p&gt;
      &lt;p&gt;
        {&quot;use_context_for_context_data's context_data_two is: &quot;}
        {use_context_for_context_data.clone().unwrap_or_default().context_data_two}
      &lt;/p&gt;

    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/mod.rs'</pre>
<pre><code class="language-rust">pub mod home.rs;
pub mod route_one.rs;
pub mod route_two.rs;
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/home.rs'</pre>
<pre><code class="language-rust">// Create Home component

use yew::prelude::*;

// 'Since Link is inside 'yew_router::prelude::*', you must use it
use yew_router::prelude::*;
// You must also use the actual &quot;Route&quot; enum which Link would wrap around
use crate::router::Route;

#[function_component(Home)]
pub fn home() -&gt; Html {
  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside the landing homepage!&quot;}&lt;/p&gt;
      {
        // Time to make a Link to another component without refreshing the page
      }
      &lt;div&gt;
        &lt;Link&lt;Route&gt;
          to={Route::RouteOne}&gt;{ &quot;Go to 'RouteOne' with no page refresh&quot; }
        &lt;/Link&lt;Route&gt;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/router_one.rs'</pre>
<pre><code class="language-rust">// Create RouterOne component

use yew::prelude::*;

#[function_component(RouterOne)]
pub fn router_one() -&gt; Html {
  html! {
    &lt;p&gt;{&quot;You are inside router-one&quot;}&lt;/p&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/routes/route_two.rs'</pre>
<pre><code class="language-rust">// Create RouterTwo component

use yew::prelude::*;
// In order to apply 'use_history', you need to use 'yew_router::prelude::*;'
// ..and 'use_history' itself
use yew_router::{prelude::*, history};

#[function_component(RouterTwo)]
pub fn router_two() -&gt; Html {

  // Time to apply 'use_history'
  let history = use_history().unwrap();

  // Clone the applied history in cas you may use &quot;history&quot; multiple times
  let history_clone = history.clone();

  // Create a callback function to respond to a click and handle it
  let click_handler = Callback::from(
    move |_| {
      // Push a route into &quot;history_clone&quot;
      history_clone.push(Route::Home);
    }
  );

  html! {
    &lt;div&gt;
      &lt;p&gt;{&quot;You are inside router-two&quot;}&lt;/p&gt;
      &lt;button onclick={click_handler}&gt;{&quot;Go back to Home (Landing Page)&quot;}&lt;/button&gt;
    &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/router.rs'</pre>
<pre><code class="language-rust">// Create &quot;router.rs&quot;

use yew::prelude::*;
// You must use 'yew_router' crate prelude to be able to create public enum &quot;Route&quot; which must implement 'Routable'
use yew_router::prelude;

// use the components which are your routes, e.g, home.rs's Home component
use crate::components::router::home::Home;
use crate::components::router::route_one::RouteOne;
use crate::components::router::route_two::RouteTwo;

// Create a public enum &quot;Route&quot; to map your router links (i.e, routing by name)
// ..and &quot;Route&quot; must implement 'Routable', Clone, and 'PartialEq'
#[derive(Debug, Clone, PartialEq, Routable)]
pub enum Route {
  #[at(&quot;/&quot;)]
  LandingPage,
  #[at(&quot;/route-one&quot;)]
  RouteOne,
  #[at(&quot;/route-two&quot;)]
  RouteTwo,
}

// You need to create a function 'switch' to return proper component based on enum 'Route'
pub fn switch(route: &amp;Route) -&gt; Html {
  match route {
    Route::Home =&gt; html! { &lt;Home /&gt; },
    Route::RouteOne =&gt; html! { &lt;RouterOne /&gt; },
    Route::RouteTwo =&gt; html! { &lt;RouterTwo /&gt; },
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/struct_based_components/struct_component_one.rs'</pre>
<pre><code class="language-rust">// Use essential files/libraries
use yew::prelude::*;

// Because of my interest in embedding another component inside the HTML rendered from this component,
// ..I have decided to use &quot;yew_project_name/src/components/sub_components_a/sub_components_a_component_1.rs&quot; component
use crate::components::sub_components_a::sub_components_a_component_1::SubComponentsAComponent1;

// Creation of a struct-based component called &quot;StructComponentOne&quot;
pub struct StructComponentOne {
  pub content_one: String,
}

// You must implement 'Component' for your struct component
impl Component for StructComponentOne {

  type Message = (); // empty tuple/unit for now
  type Properties = (); // empty tuple/unit for now

  // Constructs the component
  // Required for every struct component
  fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self {
      content_one: &quot;Hey, I am of StructComponentOne! Just like a state, without the need for a 'use_state' :-)&quot;.to_onwed(),
    }
  }

  // This function is what renders 'HTML' or one or components to the screen
  // Required for every struct component
  fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      &lt;div&gt;
        &lt;SubComponentsAComponent1 prop_one={&quot;StructComponentOne has rendered SubComponentsAComponent1!&quot;} /&gt;
        &lt;p&gt;{&quot;I, StructComponentOne, has the followiing content_one: &quot;}{&amp;self.content_one}&lt;/p&gt;
      &lt;/div&gt;
    }
  }

  // Now pay attention to the actual lifecycle methods:
  // - update
  // - changed
  // - rendered
  // - destroy

  // update
  // Activated whenever a message is updated in a struct
  fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
    // false tells Yew not to do a rerender
    false
  }

  // changed
  // Activated when a property of a struct is assigned a new value
  fn changed(&amp;mut self, ctx: &amp;Context&lt;Self&gt;) -&gt; bool {
    // true means do the rerender
    true
  }

  // rendered
  // It tells you whether or not it is the first render via 'first_render' bool,
  // ..and then inside the function you can do anything you want based on this boolean value
  // ..maybe even update internal state
  fn rendered(
    &amp;mut self,
    ctx: &amp;Context&lt;Self&gt;,
    first_render: bool
  ) {
    // --
  }

  // destroy
  // Do something when the component is being destroyed and all memory is being collected to be deallocated
  fn destroy(&amp;mut self, ctx: &amp;Context&lt;Self&gt;) {
    // --
  }

  // You will realize that you may not find use cases for 'destroy', 'rendered' and 'changed'

} // end of &quot;impl Component for StructComponentOne&quot;
</code></pre>
<pre>INSIDE "yew_project_name/src/components/struct_based_components/StructComponentTwo"</pre>
<pre><code class="language-rust">//*
//* Focus here on struct-based component &quot;StructComponentTwo&quot;
//*

use yew::prelude::*;

//* Create an enum for messaging data between &quot;StructComponentTwo&quot; lifecycle methods
pub enum StructComponentTwoAttendanceManager {
  Increase,
  Decrease
}

pub struct StructComponentTwo {
  pub attendance: u32;
}

impl Component for StructComponentTwo {

  //* 'type Message' should point to your target enum for managing data between &quot;StructComponentTwo&quot; lifecycle methods
  type Message = StructComponentTwoAttendanceManger;

  type Properties = ();

  fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self {
      attendance: 0,
    }
  }

  fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      &lt;div&gt;
        &lt;p&gt;{&quot;Attendance is at: &quot;}{self.attendance}&lt;/p&gt;
        {
          //* Trigger the lifecycle methods via a change to 'Message'
          //* ..which is &quot;StructComponentTwoAttendanceManager&quot; in this case
          //* ..using the 'onclick' attribute of a button.
        }
        &lt;button onclick={
          ctx.link().callback(|_| StructComponentTwoAttendanceManager::Increase)
        }&gt;
        {&quot;Increase attendance&quot;}
        &lt;/button&gt;

        &lt;button onclick={
          ctx.link().callback(|_| StructComponentTwoAttendanceManager::Decrease)
        }&gt;
        {&quot;Decrease attendance&quot;}
        &lt;/button&gt;
      &lt;/div&gt;
    }
  }

  //* Set what happens during an update of message &quot;StructComponentTwoAttendanceManger&quot;
  //* ..inside lifecycle method 'update'
  fn update(&amp;mut self, _ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
    match msg {
      StructComponentTwoAttendanceManager::Increase =&gt; {
        self.attendance += 1;
        true
      }
      StructComponentTwoAttendanceManager::Decrease =&gt; {
        let attendance = self.attendance;
        if attendance &gt; 0 {
          attendance -= 1;
        } else attendance = 0;
        true
      }
    }
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">use yew::prelude::*;
use stylist::yew::{styled_component, Style};
use crate::components::sub_components_a::SubComponentsAComponent1;
use crate::components::form_components::form_assembler_component::FormAssemblerComponent;
use crate::components::form_components::form_assembler_component::StatesData;

// Use &quot;crate::components::struct_based_components::struct_component_one::StructComponentOne&quot;
use crate::components::struct_based_components::struct_component_one::StructComponentOne;

//* Use &quot;crate::components::struct_based_components::struct_component_one::StructComponentTwo&quot;
use crate::components::struct_based_components::struct_component_one::StructComponentTwo;

// Use &quot;switch&quot; function and &quot;Route&quot; enum inside &quot;yew_project_name/src/router.rs&quot;
use crate::router::{Router, switch};

// You create a 'ContextProvider' at the place where you want to create a context data / object.
use yew::ContextProvider;

// You must use 'yew_router::prelude::*' in order to be able to use '&lt;Switch /&gt;' nested inside '&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;'
use yew_router::prelude::*;

// DIR &quot;struct_based_components&quot; can be found here
pub mod components;

// &quot;router&quot; is a Rust file not a dir, unlike &quot;components&quot;
pub mod router;

const EXTERNAL_STYLE = include_str!(&quot;main.css&quot;);

// &quot;ContextData&quot; will be used as a context object
#[derive(Clone, PartialEq, Default)]
pub struct ContextData {
  pub context_data_one: String,
  pub context_data_two: String,
}

#[styled_component(App)]
pub fn app() -&gt; Html {

  let external_style = Style::new(EXTERNAL_STYLE).unwrap();

  let context_data_as_state = use_state(ContextData::default); // or 'use_state( || ContextData::default() ) '

  let first_run = use_state( || true);

  use_effect(
    move || {
      if *first_run {
        first_run.set(false);
      }
      || {} // Note that you could destroy/drop data inside this closure as well
    }
  );

  let on_submit_callback_property_receipient = Callback::from(
    |received_states_data: StatesData| {
      let mut context_data = context_data_as_state.deref().clone();
      context_data.context_data_one = recieved_states_data.state_one;
      context_data.context_data_two = received_states_data.state_two;
      context_data_as_state.set(context_data);
    }
  );

  html! {
    &lt;&gt;
      &lt;div class={external_style}&gt;

        &lt;SubComponentsAComponent1 prop_one=&quot;hi&quot; /&gt;

        &lt;ContextProvider&lt;ContextData&gt; context={context_data_as_state.deref().clone()}&gt;
          &lt;FormAssemblerComponent
            input_one_value = &quot;Input 1&quot;
            input_two_value =&quot;Input 2&quot;
            button_one = &quot;Button 1&quot;
            prop_on_submit_callback_property = {on_submit_callback_property_receipient}
          /&gt;
          {
            // Time to use 'BrowserRouter'. IMPORTANT: There is no way to pass properties into a Yew router, i.e 'BrowserRouter',
            // ..but.. you can use a Context as a proxy to pass data. Mind you every sibling component of the 'BrowserRouter' would also have access
            // ..to the data as well which may be undesireable.
            // Also, imagine sibling component &quot;SubComponentsAComponent1&quot; plausibly being used as a nav-menu component ;-)
            // &quot;Route&quot; here is an enum, &quot;switch&quot; is a function which matches a &quot;Route&quot; variant to an actual route component.
          }
          &lt;BrowserRouter&gt;
            &lt;Switch&lt;Route&gt;
              render={Switch::render{switch}}
            /&gt;
          &lt;BrowserRouter&gt;
        &lt;/ContextProvider&lt;ContextData&gt;&gt;

        &lt;StructComponentOne /&gt;

        {
          //* Time to apply StructComponentTwo
        }
        &lt;StructComponentTwo /&gt;

      &lt;/div&gt;
    &lt;/&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yewdux-with-struct-components"><a class="header" href="#yewdux-with-struct-components">Yewdux with struct components</a></h2>
<pre>New DIR "yew_project_name/src/stores" created</pre>
<pre>N.B: You should actually create multiple stores for deeply integral data types to be stored</pre>
<pre>For a quick look, jump to file "yew_project_name/src/stores/sample_store_one.rs"</pre>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sample_store_one_user_component.rs
     |-sample_store_one_button_component.rs
    |-stores
     |-mod.rs
     |-sample_store_one.rs
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
gloo = &quot;0.8.0&quot; </p>
<h1 id="-it-would-see-that-no-logging-is-done-in-this-demo"><a class="header" href="#-it-would-see-that-no-logging-is-done-in-this-demo">//* It would see that no logging is done in this demo</a></h1>
<p>yewdux = &quot;0.8.2&quot; </p>
<h1 id="-you-must-depend-on-yewdux"><a class="header" href="#-you-must-depend-on-yewdux">//* You must depend on 'yewdux'</a></h1>
</pre>
</code>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">mod sample_store_one_user_component; //* file
mod sample_store_one_button_component; //* file
</code></pre>
<pre>INSIDE 'yew_project_name/src/stores/mod.rs'</pre>
<pre><code class="language-rust">mod sample_store_one; //* file
</code></pre>
<pre>INSIDE 'yew_project_name/src/stores/sample_store_one.rs'</pre>
<pre><code class="language-rust">//* You must use the yewdux prelude in the file you want to create a yewdux store
use yewdux::prelude::*;

//* You must derive 'Store', 'Default', and 'PartialEq' on the struct you want to use as your centralized store
//* You ideally should derive 'Clone' too because it is need in an alternate syntax in this demo soon to be found
#[derive(Store, PartialEq, Default, Clone)]
pub struct CentralizedStateOne {
  pub state_one: u32,
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sample_store_one_user_component'</pre>
<pre><code class="language-rust">//* Use yew and yewdux prelude
use yew::prelude::*;
use yewdux::prelude::*;

//* Make sure to use 'std::rc::Rc&quot;
use std::rc::Rc;

//* You need to use the struct &quot;CentralizedStateOne&quot; inside the file that contains the store herein,
//* ..the component that will make use of the store
use crate::stores::sample_store_one::CentralizedStateOne;

//* Since this is a yewdux and struct demo, here, a struct component is being created
pub struct SampleStoreOneUserComponent {
  //* You need a means to keep the (yewdux) store via 'dispatch' inside yewdux prelude
  pub dispatch: Dispatch&lt;CentralizedStateOne&gt;
}

//* Create an enum to be &quot;SampleStoreOneUserComponent&quot; 's  'Message' type
pub enum SSOUCMessage {
  //* Take note:
  //* Make a reference counting store out of &quot;CentralizedStateOne&quot; as a variant
  Store(Rc&lt;CentralizedStateOne&gt;),
}

//* impl 'Component' for &quot;SampleStoreOneUserComponent&quot; created up above
impl Component for SampleStoreOneUserComponent {

  type Message = SSOUCMessage;
  type Properties = ();

  fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    //* Make sure you have your dispatch as soon as this component is created
    let dispatch = Dispatch::CentralizedStateOne::subscribe(
      ctx.link().callback(SSOUCMessage::Store)
    )//* &quot;ctx.link()&quot; is the value of 'onchange', while &quot;SSOUCMessage::Store&quot; is the value of 'function'

    Self {dispatch} //* &quot;dispatch&quot; herein basically makes it possible to retreive the central state/store data as a message
  }

  //* Tell your component to update when any centralized-store/state item updates; i.e, changes to a new value
  fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
    match msg {
      SSOUCMessage::Store(_) =&gt; true,
    }
  }

  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    //* Time to receive &quot;state_one&quot; inside &quot;CentralizedStateOne&quot;
    let almost_state_one = self.dispatch.get(); //* This returns an Rc to &quot;CentralizedStateOne&quot; store inside enum &quot;SSOUCMessage&quot;
    let state_one = almost_state_one.state_one; //* Now you get &quot;state_one&quot; stored inside store struct &quot;CentralizedStateOne&quot;
    html! {
      &lt;div&gt;
        &lt;h4&gt;{&quot;State one below&quot;}&lt;/h4&gt;
        &lt;div&gt;{state_one}&lt;/div&gt;
      &lt;/div&gt;
    }
  }

}
</code></pre>
<pre>INSIDE "yew_project_name/src/components/sample_store_one_button_component"</pre>
<pre><code class="language-rust">use yew::prelude::*;
use yewdux::prelude::*;
use std::rc::Rc;

use crate::stores::sample_store_one::CentralizedStateOne;

pub struct SampleStoreOneButtonComponent {
  pub dispatch: Dispatch&lt;CentralizedStateOne&gt;
}

//* Create an enum to be &quot;SampleStoreOneButtonComponent&quot; 's  'Message' type
pub enum SSOBCMessage {
  Store(Rc&lt;CentralizedStateOne&gt;),
  ButtonClicked,
}

impl Component for SampleStoreOneButtonComponent {

  type Message = SSOBCMessage;
  type Properties = ();

  fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    //* Make sure you have your dispatch as soon as this component is created
    let dispatch = Dispatch::CentralizedStateOne::subscribe(
      ctx.link().callback(SSOBCMessage::Store)
    )//* &quot;ctx.link()&quot; is the value of 'onchange', while &quot;SSOCMessage::Store&quot; is the value of 'function'

    Self {dispatch} //* &quot;dispatch&quot; herein basically makes it possible to retreive the message in the central state/store as data for first render
  }

  //* Control changes to the central store via clicks to button here
  //* Mind you, this is a button component
  fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
    match msg {

      SSOBCMessage::Store(_store) =&gt; false,
      SSOBCMessage::ButtonClicked =&gt; { //* &quot;store&quot; herein is an 'Rc&lt;CentralizedStateOne&gt;'
        /*self.dispatch.reduce(|store| CentralizedStateOne {
          state_one: store.state_one + 1; // The more the button is clicked, the higher &quot;state_one&quot; ' value (inside &quot;CentralizedStateOne&quot;) will be.
        });
        */ //* alternate syntax;
        self.dispatch.reduce_mut(|store| {
          //store.state_one += 1; //* &quot;store here is now a mutable reference to &quot;CentralizedStateOne&quot;
        });
        false
      }

    }
  }

  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {

    //* Function to respond to button clicks
    //* The response here is to trigger a 'Message' (which in our case is an enum variant &quot;ButtonClicked&quot;), causing it to the fire the 'update' lifecycle method
    //* Take Note: the '.callback()' arg here is different from the one in the 'view' lifecycle method
    let onclick_response = ctx.link().callback(|_| SSOBCMessage::ButtonClicked);
    html! {
      &lt;button onclick={onclick_response&gt;
        {&quot;Effect update&quot;}
      &lt;/button&gt;
    }

  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">//* expose sibling DIR 'stores'
mod stores; //* DIR
mod components; //* DIR

use yew::prelude::*;

//* Use the struct component that interacts with a yewdux centralized state/store
use crate::components::sample_store_one_user_component::SampleStoreOneUserComponent;
//* Use the struct button component that interacts with a yewdux centralized state/store
//* ..via its 'Message' type and &quot;dispatch&quot; (state-like) property which points to &quot;CentralizedStateOne&quot;
use crate::components::sample_store_one_button_component::SampleStoreOneButtonComponent;

pub struct App{}

impl Component for App {

  type Message = ();
  type Properties = ();

  fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self{}
  }

  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      &lt;div&gt;

        &lt;h2&gt;{&quot;You are inside app, the beginning of this app&quot;}&lt;/h2&gt;

        {
          //* Time to use the component that interacts with a yewdux centralized state/store
        }
        &lt;span&gt;
          &lt;SampleStoreOneUserComponent /&gt;
          &lt;SampleStoreOneButtonComponent /&gt;
        &lt;/span&gt;
      &lt;/div&gt;
    }
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yewdux-with-struct-components-form-demo"><a class="header" href="#yewdux-with-struct-components-form-demo">Yewdux with struct components (Form Demo)</a></h2>
<pre>New DIR "yew_project_name/src/stores" created</pre>
<pre>N.B: You should actually create multiple stores for deeply integral data types to be stored</pre>
<pre>For a quick look, jump to file:
   - "yew_project_name/src/stores/sample_store_two.rs"
   - "yew_project_name/src/components/sample_store_two_user_component.rs"
   - "yew_project_name/src/components/sample_store_two_summary_component.rs"</pre>
<pre>!!! Read this!!!
  In this demo, a centralized store/state will be created to manage a hypothetical form data
  ..and you'll be able to use or summarize the centralized state/store data at the click of a button</pre>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sample_store_one_user_component.rs
     |-sample_store_one_button_component.rs
     |-sample_store_two_user_component.rs
     |-sample_store_two_summary_component.rs
    |-stores
     |-mod.rs
     |-sample_store_one.rs
     |-sample_store_two.rs
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
stylist = {version = &quot;0.10.8&quot; features = [&quot;yew&quot;]}
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version=&quot;0.3.60&quot;, features = [&quot;HtmlInputElement&quot;] } # //* You must depend on 'web-sys'
yewdux = &quot;0.8.2&quot; # //* You must depend on 'yewdux'
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">mod sample_store_one_user_component; // file not needed anymore
mod sample_store_one_button_component; // file not needed anymore
mod sample_store_two_user_component; //* file
mod sample_store_two_summary_component; //* file
</code></pre>
<pre>INSIDE 'yew_project_name/src/stores/mod.rs'</pre>
<pre><code class="language-rust">mod sample_store_one; //* file not needed anynore
mod sample_store_two; //* .rs file
</code></pre>
<pre><code class="language-rust">/*
  !!! NOT NEEDED ANYMORE !!!
// INSIDE 'yew_project_name/src/stores/sample_store_one.rs'

// You must use the yewdux prelude in the file you want to create a yewdux store
use yewdux::prelude::*;

// You must derive 'Store', 'Default', and 'PartialEq' on the struct you want to use as your centralized store
// You ideally should derive 'Clone' too because it is needed in an alternate syntax in this demo soon to be found
#[derive(Store, PartialEq, Default, Clone)]
pub struct CentralizedStateOne {
  pub state_one: u32,
}
*/
</code></pre>
<pre>INSIDE 'yew_project_name/src/stores/sample_store_two.rs'</pre>
<pre><code class="language-rust">//* You must use the yewdux prelude inside the file you want ot create a yewdux store in
use yewdux::prelude::*;

//* You must derive 'Store', 'Default', and 'PartialEq' on the struct you want to use as your centralized store
//* You ideally should derive 'Clone' too because it is needed in an alternate syntax in this demo soon to be found
#[derive(Store, PartialEq, Default, Clone)]
pub struct CentralizedFormState {
  pub state_one_input: Option&lt;String&gt;,
  pub state_two_input: Option&lt;String&gt;,
  pub state_one_and_two_input_entry_set: bool,
}
</code></pre>
<pre><code class="language-rust">/*
  !!! NOT NEEDED ANYMORE !!!
// INSIDE 'yew_project_name/src/components/sample_store_one_user_component'

use yew::prelude::*;
use yewdux::prelude::*;

use std::rc::Rc;

use crate::stores::sample_store_one::CentralizedStateOne;

pub struct SampleStoreOneUserComponent {
  // You need a means to keep the (yewdux) store via 'dispatch' inside yewdux prelude
  pub dispatch: Dispatch&lt;CentralizedStateOne&gt;
}

// Create an enum to be &quot;SampleStoreOneUserComponent&quot; 's  'Message' type
pub enum SSOUCMessage {
  // The only variant of &quot;SSOUCMessage&quot; is &quot;Store(Rc&lt;CentralizedStateOne&gt;)&quot;, hmm..
  Store(Rc&lt;CentralizedStateOne&gt;),
}

impl Component for SampleStoreOneUserComponent {

  type Message = SSOUCMessage;
  type Properties = ();

  fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {

    // Make sure you have your dispatch as soon as this component is created
    let dispatch = Dispatch::CentralizedStateOne::subscribe(
      ctx.link().callback(SSOUCMessage::Store)
    )// &quot;ctx.link()&quot; is the value of 'onchange', while &quot;SSOUCMessage::Store&quot; is the value of 'function'

    Self {dispatch} //* &quot;dispatch&quot; herein basically makes it possible to retreive the central state/store data as a message

  }

  // Tell your component to update when any centralized-store/state item updates; i.e, changes to a new value
  fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
    match msg {
      SSOUCMessage::Store(_) =&gt; true,
    }
  }

  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {

    let almost_state_one = self.dispatch.get(); // This returns an Rc to &quot;CentralizedStateOne&quot; store inside enum &quot;SSOUCMessage&quot;
    let state_one = almost_state_one.state_one; // Now you get &quot;state_one&quot; stored inside store struct &quot;CentralizedStateOne&quot;
    html! {
      &lt;div&gt;
        &lt;h4&gt;{&quot;State one below&quot;}&lt;/h4&gt;
        &lt;div&gt;{state_one}&lt;/div&gt;
      &lt;/div&gt;
    }

  }

}
*/
</code></pre>
<pre><code class="language-rust">/*
  !!! NOT NEEDED ANYMORE !!!
// INSIDE &quot;yew_project_name/src/components/sample_store_one_button_component&quot;

use yew::prelude::*;
use yewdux::prelude::*;
use std::rc::Rc;

use crate::stores::sample_store_one::CentralizedStateOne;

pub struct SampleStoreOneButtonComponent {
  pub dispatch: Dispatch&lt;CentralizedStateOne&gt;
}

// Create an enum to be &quot;SampleStoreOneButtonComponent&quot; 's  'Message' type
pub enum SSOBCMessage {
  Store(Rc&lt;CentralizedStateOne&gt;),
  ButtonClicked, // This time there is another variant, hmm..
}

impl Component for SampleStoreOneButtonComponent {

  type Message = SSOBCMessage;
  type Properties = ();

  fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {

    let dispatch = Dispatch::CentralizedStateOne::subscribe(
      ctx.link().callback(SSOBCMessage::Store)
    )//* &quot;ctx.link()&quot; is the value of 'onchange', while &quot;SSOCMessage::Store&quot; is the value of 'function'

    Self {dispatch} // &quot;dispatch&quot; herein basically makes it possible to retreive the message in the central state/store as data for first render

  }

  // Control changes to the central store via clicks to button here
  // Mind you, this is a button component
  fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {

    match msg {

      SSOBCMessage::Store(_store) =&gt; false,
      SSOBCMessage::ButtonClicked =&gt; { // &quot;store&quot; herein is an 'Rc&lt;CentralizedStateOne&gt;'
        /*self.dispatch.reduce(|store| CentralizedStateOne {
          state_one: store.state_one + 1; //* The more the button is clicked, the higher &quot;state_one&quot; ' value (inside &quot;CentralizedStateOne&quot;) will be.
        });
        */ // alternate syntax;  Now this is why &quot;CentralizedStateOne&quot; needed to derive 'Clone'
        self.dispatch.reduce_mut(|store| {
          //store.state_one += 1; //* &quot;store here is now a mutable reference to &quot;CentralizedStateOne&quot;
        });
        false
      }

    }

  }

  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {

    //* Function to respond to button clicks
    //* The response here is to trigger a 'Message' (which in our case is an enum variant &quot;ButtonClicked&quot;), causing it to the fire the 'update' lifecycle method
    //* Take Note: the '.callback()' arg here is different from the one in the 'view' lifecycle method
    let onclick_response = ctx.link().callback(|_| SSOBCMessage::ButtonClicked);
    html! {
      &lt;button onclick={onclick_response&gt;
        {&quot;Effect update&quot;}
      &lt;/button&gt;
    }

  }

}
*/
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sample_store_two_user_component'</pre>
<pre><code class="language-rust">//* Important File.

//* Use yew and yewdux prelude
use yew::prelude::*;
use yewdux::prelude::*;

//* You need to use 'web_sys::HtmlInputElement' to handle input and respond to them via input attribute 'onchange'
use web_sys::HtmlInputElement;

//* Make sure to use 'std::rc::Rc&quot;
use std::rc::Rc;

//* You need to use the struct &quot;CentralizedStateOne&quot; inside the file that contains the store herein,
//* ..the component that will make use of the store
use crate::stores::sample_store_two::CentralizedFormState;

//* Since this is a yewdux and struct demo, here, a struct component is being created
pub struct SampleStoreTwoUserComponent {
  //* You need a means to keep the (yewdux) store &quot;CentralizedFormState&quot; via 'dispatch' inside yewdux prelude
  pub dispatch: Dispatch&lt;CentralizedFormState&gt;
}

//* Create an enum to be &quot;SampleStoreTwoUserComponent&quot; 's  'Message' type
pub enum SSTUCMessage {

  //* Take note:
  //* Make a reference counting store out of &quot;CentralizedFormState&quot; as a variant
  Store(Rc&lt;CentralizedFormState&gt;),

  //* Create enum variants with which you would use to affect states inside &quot;CentralizedFormState&quot;
  StateOneInputMessage(String)
  StateTwoInputMessage(String),
  ReleaseFormData,

}

//* impl 'Component' for &quot;SampleStoreTwoUserComponent&quot; created up above
impl Component for SampleStoreTwoUserComponent {

  type Message = SSTUCMessage;
  type Properties = ();

  fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    //* Make sure you have your dispatch as soon as this component is created
    let dispatch = Dispatch::CentralizedFormState::subscribe(
      ctx.link().callback(SSTUCMessage::Store)
    )//* &quot;ctx.link()&quot; is the value of 'onchange', while &quot;SSTUCMessage::Store&quot; is the value of 'function'

    Self {dispatch} //* &quot;dispatch&quot; herein basically makes it possible to retreive the central state/store data as a message
  }

  //* Tell your component to update when a specific centralized-store/state item updates; i.e, changes to a new value
  //* This component &quot;SampleStoreTwoUserComponent&quot; will only update when when a button is clicked with will trigger the &quot;ReleaseFormData&quot; enum's &quot;SSTUCMessage&quot; variant
  fn update(&amp;mut self, _ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {

    match msg {
      SSTUCMessage::Store(_) =&gt; false,
      SSTUCMessage::StateOneInputMessage(received_input) =&gt; {
        self.dispatch.reduce_mut(|centralized_form_state| {
          centralized_form_state.state_one_input = Some(received_input)
        });
        false
      },
      SSTUCMessage::StateTwoInputMessage(received_input) =&gt; {
        self.dispatch.reduce_mut(|centralized_form_state| {
          centralized_form_state.state_two_input = Some(received_input)
        });
        false
      }
      SSTUCMessage::ReleaseFormData =&gt; { //* Potential means to put form validation logic inside a block and then return true or false as the choice may be :)

        //* Here, we are making sure SSTUCMessage variants &quot;StateOneInputMessage&quot; and &quot;StateTwoInputMessage&quot; have been set before releasing form data
        self.dispatch.reduce_mut(|centralized_form_state| {
          //* This code block returns true
          centralized_form_state.state_one_and_two_input_entry_set = {
            centralized_form_state.state_one_input.is_some() &amp;&amp;
            centralized_form_state.state_two_input.is_some()
          }
        });

        //* Time to return either true or false
        false

      }
    }

  }

  fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {

    //* Create callback function that supply input to input &quot;state_one_input&quot; of &quot;CentralizedFormState&quot;
    let supply_state_one_input = ctx.link().callback(
      |event: Event| {
        //* Extract input data via 'event.target'
        let target = event.target_unchecked_into::&lt;HtmlInputElement&gt;();
        let input = target.value();
        SSTUCMessage::StateOneInputMessage(input);
      }
    );

    //* Create callback function that supply input to input &quot;state_one_input&quot; of &quot;CentralizedFormState&quot;
    let supply_state_two_input = ctx.link().callback(
      |event: Event| {
        //* Extract input data via 'event.target'
        let target = event.target_unchecked_into::&lt;HtmlInputElement&gt;();
        let input = target.value();
        SSTUCMessage::StateTwoInputMessage(input);
      }
    );

    //* Create a callback function which will respond to an 'onsubmit' event of the form element
    let onsubmit_response = ctx.link().callback(
      |event: FocusEvent| {
        event.prevent_default();
        //* Return &quot;ReleaseFormData&quot; Message variant
        SSTUCMessage::ReleaseFormData
      }
    );

    html! {
      &lt;form onsubmit_response&gt;
        &lt;h4&gt;{&quot;Form data released below&quot;}&lt;/h4&gt;

        &lt;div&gt;
          &lt;div&gt;
            &lt;label for=&quot;state-one-input&quot;&gt;{&quot;StateOneInputMessage&quot;}&lt;/label&gt;
          &lt;/div&gt;
          &lt;div&gt;
            {
              //* You must assign the 'onchange' attribute of this input in the case to &quot;supply_state_one_input&quot; so it
              //* ..can supply it the input received
            }
            &lt;input type=&quot;text&quot; id=&quot;state-one-input&quot; onchange={supply_state_one_input} placeholder=&quot;StateOneInputMessage&quot; /&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;div&gt;
            &lt;label for=&quot;state-two-input&quot;&gt;{&quot;StateTwoInputMessage&quot;}&lt;/label&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;input type=&quot;password&quot; id=&quot;state-two-input&quot; onchange={supply_state_two_input} placeholder=&quot;StateTwoInputMessage&quot; /&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;button&gt;{&quot;ReleaseFormData&quot;}&lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    }

  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sample_store_two_summary_component'</pre>
<pre><code class="language-rust">//* Another important file for this demo
//* The entire file is important
//* Important. Take Note!!

use yew::prelude::*;
use yewdux::prelude::*;

use crate::stores::sample_store_two::CentralizedFormState;

pub struct SampleStoreTwoSummaryComponent {
  dispatch: Dispatch&lt;CentralizedFormState&gt;,
}

pub enum SSTSCMessage {
  Store(Rc&lt;CentralizedFormState&gt;),
}

impl Component for SampleStoreTwoSummaryComponent {

  type Message = SSTSCMessage;
  type Properties = ();

  //* The 'create' life-cycle method
  fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    let dispatch = Dispatch::&lt;CentralizedFormState&gt;::subscribe(
      ctx.link().callback(SSTSCMessage::Store)
    );
    Self { dispatch }
  }

  //* The 'update' life-cycle method
  fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
    match msg {
      SSTSCMessage::Store(_) =&gt; true,
    }
  }

  //* The 'view' life-cycle method
  fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {

    let centralized_form_state = self.dispatch.get();

    let state_one_input_summary = format!(
      &quot;State one is: {}&quot;,
      centralized_form_state.state_one_input.as_deref()unwrap_or_default()
    );
    let state_two_input_summary = format!(
      &quot;State two is: {}&quot;,
      centralized_form_state.as_deref().state_two_input.unwrap_or_default()
    );
    let state_one_and_two_input_entry_set_summary = format!(
      &quot;State one and two input entry set true/false: {:?}&quot;,
      centralized_form_state.state_one_and_two_input_entry_set
    );

    html! {
      &lt;div&gt;
        &lt;h3&gt;{&quot;CentralizedFormState Data Summary&quot;}&lt;/h3&gt;
        &lt;div&gt;{state_one_input_summary}&lt;/div&gt;
        &lt;div&gt;{state_two_input_summary}&lt;/div&gt;
        &lt;div&gt;{state_one_and_two_input_entry_set_summary}&lt;/div&gt;
      &lt;/div&gt;
    }

  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">//* expose sibling DIR 'stores'
mod stores; //* DIR
mod components; //* DIR

use yew::prelude::*;

//* This component is not needed anymore
use crate::components::sample_store_one_user_component::SampleStoreOneUserComponent;

//* Use &quot;SampleStoreTwoUserComponent&quot;
use crate::components::sample_store_two_user_component::SampleStoreTwoUserComponent;
//* Also use &quot;SampleStoreTwoSummaryComponent&quot;
use crate::components::sample_store_two_summary_component::SampleStoreTwoSummaryComponent;

//* This component is not needed anymore
use crate::components::sample_store_one_button_component::SampleStoreOneButtonComponent;

pub struct App{}

impl Component for App {

  type Message = ();
  type Properties = ();

  fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self{}
  }

  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      &lt;div&gt;

        &lt;h2&gt;{&quot;You are inside app, the beginning of this app&quot;}&lt;/h2&gt;

        &lt;div&gt;

          {
            //* Component not needed anymore
          }
          &lt;SampleStoreOneUserComponent /&gt;


          {
            //* Component not needed anymore
          }
          &lt;SampleStoreOneButtonComponent /&gt;

          {
            //* Time to use the relevant component(s) that interacts with a yewdux centralized state/store
          }
          &lt;SampleStoreTwoUserComponent /&gt;
          &lt;SampleStoreTwoSummaryComponent /&gt;

        &lt;/div&gt;

      &lt;/div&gt;
    }
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yewdux-with-functional-components-form-demo"><a class="header" href="#yewdux-with-functional-components-form-demo">Yewdux with functional components (Form Demo)</a></h2>
<pre>New DIR "yew_project_name/src/stores" created</pre>
<pre>N.B: You should actually create multiple stores for deeply integral data types to be stored</pre>
<pre>For a quick look, jump to file:
   - "yew_project_name/src/stores/sample_store.rs"
   - "yew_project_name/src/components/sample_store_user_component.rs"
   - "yew_project_name/src/components/sample_store_summary_component.rs"</pre>
<p>In this demo, a centralized store/state will be created to manage a hypothetical form data</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sample_store_user_component.rs
     |-sample_store_summary_component.rs
    |-stores
     |-mod.rs
     |-sample_store.rs
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
<pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version=&quot;0.3.60&quot;, features = [&quot;HtmlInputElement&quot;] } # //* You must depend on 'web-sys'
yewdux = &quot;0.8.2&quot; # //* You must depend on 'yewdux'
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">mod sample_store_user_component; //* file
mod sample_store_summary_component; //* file
</code></pre>
<pre>INSIDE 'yew_project_name/src/stores/mod.rs'</pre>
<pre><code class="language-rust">mod sample_store; //* file
</code></pre>
<pre>INSIDE 'yew_project_name/src/stores/sample_store.rs'</pre>
<pre><code class="language-rust">//* You must use the yewdux prelude inside the file you want ot create a yewdux store in
use yewdux::prelude::*;

//* You must derive 'Store', 'Default', and 'PartialEq' on the struct you want to use as your centralized store
//* You ideally should derive 'Clone' too because it is needed in an alternate syntax in this demo soon to be found
#[derive(Store, PartialEq, Default, Clone)]
pub struct CentralizedFormState {
  pub state_one_input: Option&lt;String&gt;,
  pub state_two_input: Option&lt;String&gt;,
  pub state_one_and_two_input_entry_set: bool,
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sample_store_user_component'</pre>
<pre><code class="language-rust">//* Important File.

//* Use yew and yewdux prelude
use yew::prelude::*;
use yewdux::prelude::*;

//* You need to use 'web_sys::HtmlInputElement' to handle input and respond to them via input attribute 'onchange'
use web_sys::HtmlInputElement;

//* You need to use the struct &quot;CentralizedStateOne&quot; inside the file that contains the store herein,
//* ..the component that will make use of the store
use crate::stores::sample_store::CentralizedFormState;

//* Create your function component
#[function_component(SampleStoreUserComponent)]
pub fn sample_store_user_component() -&gt; Html {

  //* Make use of hook 'use_store' which returns a tuple of 'Rc&lt;S&gt;' and 'Dispatch&lt;S&gt;' where 'S' is your centralized state/store of choice
  let (_, centralized_form_state_dispatch) = use_store::&lt;CentralizedFormState&gt;::();

  //* Create a Callback for the 'onchange' attribute of an input corresponding to &quot;state_one_input&quot; of &quot;CentralizedFormState&quot;
  let supply_state_one_input = {
    //* Clone &quot;centralized_form_state_dispatch&quot; so that it can be safely moved
    let cloned_centralized_form_state_dispatch = centralized_form_state_dispatch.clone();

    Callback::from(
      move |event: Event| {
        let received_state_one_input_value = event.target_unchecked_into::&lt;HtmlInputElement&gt;::value();
        let verified_received_state_one_input_value = if received_state_one_input_value.is_empty() {
          None
        } else {
          Some(received_state_one_input_value)
        };
        //* Time to use &quot;cloned_centralized_form_state_dispatch&quot; to assign new input value to &quot;state_one_input&quot;
        cloned_centralized_form_state_dispatch.reduce_mut(
          |retrieved_store| retrieved_store.state_one_input = verified_received_state_one_input_value
        );
      }
    ) //* end of 'Callback::from'
  };

  let cloned_centralized_form_state_dispatch = centralized_form_state_dispatch.clone(); //* Cloning not necessary though

  //* Create a (better) Callback for the 'onchange' attribute of an input corresponding to &quot;state_two_input&quot; of &quot;CentralizedFormState&quot;
  let supply_state_two_input = cloned_centralized_form_state_dispatch.reduce_mut_callback_with(
      |retrieved_store, event: Event| {
        let received_state_two_input_value = event.target_unchecked_into::&lt;HtmlInputElement&gt;::value();
        retrieved_store.state_two_input = if received_state_two_input_value.is_empty() {
          None
        } else {
          Some(received_state_two_input_value)
        }; //* conditional-check plays the role of a verified &quot;received_state_two_input&quot;
      }
  );

  let cloned_centralized_form_state_dispatch = centralized_form_state_dispatch.clone(); //* Cloning not necessary though

  //* Create a Callback for the 'onsubmit' attribute of the whole form which would then trigger component &quot;SampleStoreSummaryComponent&quot;
  let onsubmit_response = cloned_centralized_form_state_dispatch.reduce_mut_callback_with(
      |retrieved_store, event: FocusEvent| {
        event.prevent_default();
        retrieved_store.state_one_two_input_entry_set = retrieved_store.state_one_input.is_some() &amp;&amp; retieved_store.state_two_input.is_some();
      }
  );

  html! {
    &lt;form onsubmit_response&gt;
      &lt;h4&gt;{&quot;Form data released below&quot;}&lt;/h4&gt;

      &lt;div&gt;
        &lt;div&gt;
          &lt;label for=&quot;state-one-input&quot;&gt;{&quot;StateOneInput&quot;}&lt;/label&gt;
        &lt;/div&gt;
        &lt;div&gt;
          {
            //* You must assign the 'onchange' attribute of this input in the case to &quot;supply_state_one_input&quot; so it
            //* ..can supply it the input received
          }
          &lt;input type=&quot;text&quot; id=&quot;state-one-input&quot; onchange={supply_state_one_input} placeholder=&quot;StateOneInput&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;div&gt;
          &lt;label for=&quot;state-two-input&quot;&gt;{&quot;StateTwoInput&quot;}&lt;/label&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;input type=&quot;password&quot; id=&quot;state-two-input&quot; onchange={supply_state_two_input} placeholder=&quot;StateTwoInput&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;button&gt;{&quot;ReleaseFormData&quot;}&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sample_store_summary_component'</pre>
<pre><code class="language-rust">//* Another important file for this demo
//* The entire file is important
//* Important. Take Note!!

use yew::prelude::*;
use yewdux::prelude::*;

use crate::stores::sample_store::CentralizedFormState;

//* Create your SampleStoreSummaryComponent function-component
#[function_component(SampleStoreSummaryComponent)]
pub fn sample_store_summary_component() -&gt; Html {

  //* * Since there is no plan to pass data to a centralized state/store, dispatch is not needed :)
  let (retrieved_store, _) = use_store::&lt;CentralizedFormState&gt;();

  let retrieved_state_one_input = format!(
    &quot;State one input is: {}&quot;,
    retrieved_store.state_one_input.as_deref().unwrap_or_default()
  );

  let retrieved_state_two_input = format!(
    &quot;State two input is: {}&quot;,
    retrieved_store.state_two_input.as_deref().unwrap_or_default()
  );

  let retrieved_state_one_and_two_input_entry_set = format!(
    &quot;State one and two input entry set true/false&quot;: {:?},
    retrieved_store.state_one_and_two_input_entry_set.as_deref().unwrap_or_default()
  );

  html! {
    &lt;div&gt;
        &lt;h3&gt;{&quot;CentralizedFormState Data Summary&quot;}&lt;/h3&gt;
        &lt;div&gt;{retrieved_state_one_input}&lt;/div&gt;
        &lt;div&gt;{retrieved_state_two_input}&lt;/div&gt;
        &lt;div&gt;{retrieved_state_one_and_two_input_entry_set}&lt;/div&gt;
      &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">//* expose sibling DIR 'stores'
mod stores; //* DIR
mod components; //* DIR

use yew::prelude::*;

//* This component is not needed anymore
use crate::components::sample_store_one_user_component::SampleStoreOneUserComponent;

//* Use &quot;SampleStoreUserComponent&quot;
use crate::components::sample_store_user_component::SampleStoreUserComponent;
//* Also use &quot;SampleStoreSummaryComponent&quot;
use crate::components::sample_store_summary_component::SampleStoreSummaryComponent;

//* This component is not needed anymore
use crate::components::sample_store_one_button_component::SampleStoreOneButtonComponent;

pub struct App{}

impl Component for App {

  type Message = ();
  type Properties = ();

  fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self{}
  }

  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      &lt;div&gt;

        &lt;h2&gt;{&quot;You are inside app, the beginning of this app&quot;}&lt;/h2&gt;

        &lt;div&gt;

          {
            //* Component not needed anymore
          }
          &lt;SampleStoreOneUserComponent /&gt;


          {
            //* Component not needed anymore
          }
          &lt;SampleStoreOneButtonComponent /&gt;

          {
            //* Time to use the relevant component(s) that interacts with a yewdux centralized state/store
          }
          &lt;SampleStoreUserComponent /&gt;
          &lt;SampleStoreSummaryComponent /&gt;

        &lt;/div&gt;

      &lt;/div&gt;
    }
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yewdux-for-persistent-storage-in-functional-components-form-demo"><a class="header" href="#yewdux-for-persistent-storage-in-functional-components-form-demo">Yewdux for persistent storage in functional components (Form Demo)</a></h2>
<pre>New DIR "yew_project_name/src/stores" created</pre>
<pre>N.B: You should actually create multiple stores for deeply integral data types to be stored</pre>
<pre>For a quick look, jump to file:
   - "yew_project_name/src/stores/sample_store.rs"
   - "yew_project_name/src/components/sample_store_user_component.rs"
   - "yew_project_name/src/components/sample_store_summary_component.rs"</pre>
<p>In this demo, a centralized state store will be created to manage a hypothetical form data for function components
and you'd see how data can be added, changed, and even requested from the centralized state store.</p>
<p>Yew folder structure::</p>
<pre>
  |-yew_project_name
   |-dist
   |-src
    |-components
     |-mod.rs
     |-sample_store_user_component.rs
     |-sample_store_summary_component.rs
    |-stores
     |-mod.rs
     |-sample_store.rs
    |-lib.rs
    |-main.rs
   |-target
   |-Cargo.lock
   |-Cargo.toml
   |-index.html
</pre>
<pre>INSIDE 'Cargo.toml'</pre>
<code>
  <pre>
[package]
name = "yew_project_name"
version = "0.1.0"
edition = "2021"
<p>[dependencies]
yew = &quot;0.19.3&quot;
wasm-bindgen = &quot;0.2.79&quot;
web-sys = { version=&quot;0.3.60&quot;, features = [&quot;HtmlInputElement&quot;] } </p>
<h1 id="-you-must-depend-on-web-sys"><a class="header" href="#-you-must-depend-on-web-sys">//* You must depend on 'web-sys'</a></h1>
<p>yewdux = &quot;0.8.2&quot; </p>
<h1 id="-you-must-depend-on-yewdux-1"><a class="header" href="#-you-must-depend-on-yewdux-1">//* You must depend on 'yewdux'</a></h1>
<p>yewdux-functional = &quot;8.1.0&quot;
serde = &quot;1.0.136&quot;
</pre>
</code></p>
<pre>INSIDE 'yew_project_name/src/components/mod.rs'</pre>
<pre><code class="language-rust">mod sample_store_user_component; //* file
mod sample_store_summary_component; //* file
</code></pre>
<pre>INSIDE 'yew_project_name/src/stores/mod.rs'</pre>
<pre><code class="language-rust">mod sample_store; //* file
</code></pre>
<pre>INSIDE 'yew_project_name/src/stores/sample_store.rs'</pre>
<pre><code class="language-rust">//* You must use the yewdux prelude inside the file you want ot create a yewdux store in
use yewdux::prelude::*;

// You must derive 'Store', 'Default', and 'PartialEq' on the struct you want to use as your centralized store
//* You must serialize and deserialize, i.e, derive 'Serialize' and 'Deserialize'
#[derive(Store, PartialEq, Default, Clone, Serialize, Deserialize)]
pub struct CentralizedFormState {
  pub state_one_input: Option&lt;String&gt;,
  pub state_two_input: Option&lt;String&gt;,
  pub state_one_and_two_input_entry_set: bool,
}

/*
// Not needed, old yew way of doing things code
pub fn init() -&gt; Dispatch&lt;BasicStore&lt;CentralizedFormState&gt;&gt; {
  Dispatch::&lt;BasicStore&lt;CentralizedFormState&gt;&gt;::new()
}
*/

//*
impl Persistent for CentralizedFormState {

  //* This is going to be the key that is stored up in local storage
  fn key() -&gt; &amp;'static str {
    // std::any::type_name::&lt;Self&gt;() //* default function signature of 'key' and it'll return the name of your centralized store &quot;CentralizedFormState&quot;
    //* You can return any much more suitable &amp;str, e.g;
    &quot;Yew_for_persistent_storage_in_functional_component&quot; //* ..literally anything :)
  }

  //* You specify what storage your centralized store/state will be stored via this function
  //* You have to choose between 'Local' storage and 'Session' storage. Note, 'Local' is more resilient, while sessioned has a short time (the user's session)
  fn area() -&gt; Area {
    Area::Local //* To choose 'Session', use 'Area::Session' instead.
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sample_store_user_component'</pre>
<pre><code class="language-rust">// Important File.

use yew::prelude::*;
use yewdux::prelude::*;

//* use 'yewdux_functional::use_store'
use yewdux_functional::use_store

// You need to use 'web_sys::HtmlInputElement' to handle input and respond to them via input attribute 'onchange'
use web_sys::HtmlInputElement;

// You need to use the struct &quot;CentralizedStateOne&quot; inside the file that contains the store herein,
// ..the component that will make use of the store
use crate::stores::sample_store::CentralizedFormState;

//* Create your function component
#[function_component(SampleStoreUserComponent)]
pub fn sample_store_user_component() -&gt; Html {

  /*
  // * Radical change made to this code, look below the block-comment
  // Make use of hook 'use_store' which returns a tuple of 'Rc&lt;S&gt;' and 'Dispatch&lt;S&gt;' where 'S' is your centralized state/store of choice
  let (_, centralized_form_state_dispatch) = use_store::&lt;CentralizedFormState&gt;::();

  let supply_state_one_input = {

    let cloned_centralized_form_state_dispatch = centralized_form_state_dispatch.clone();

    Callback::from(
      move |event: Event| {
        let received_state_one_input_value = event.target_unchecked_into::&lt;HtmlInputElement&gt;::value();
        let verified_received_state_one_input_value = if received_state_one_input_value.is_empty() {
          None
        } else {
          Some(received_state_one_input_value)
        };
        // Time to use &quot;cloned_centralized_form_state_dispatch&quot; to assign new input value to &quot;state_one_input&quot;
        cloned_centralized_form_state_dispatch.reduce_mut(
          |retrieved_store| retrieved_store.state_one_input = verified_received_state_one_input_value
        );
      }
    ) // end of 'Callback::from'
  };

  let cloned_centralized_form_state_dispatch = centralized_form_state_dispatch.clone(); // * Cloning not necessary though

  // Create a (better) Callback for the 'onchange' attribute of an input corresponding to &quot;state_two_input&quot; of &quot;CentralizedFormState&quot;
  let supply_state_two_input = cloned_centralized_form_state_dispatch.reduce_mut_callback_with(
      |retrieved_store, event: Event| {
        let received_state_two_input_value = event.target_unchecked_into::&lt;HtmlInputElement&gt;::value();
        retrieved_store.state_two_input = if received_state_two_input_value.is_empty() {
          None
        } else {
          Some(received_state_two_input_value)
        }; // * conditional-check plays the role of a verified &quot;received_state_two_input&quot;
      }
  );

  let cloned_centralized_form_state_dispatch = centralized_form_state_dispatch.clone(); // * Cloning not necessary though

  // Create a Callback for the 'onsubmit' attribute of the whole form which would then trigger component &quot;SampleStoreSummaryComponent&quot;
  let onsubmit_response = cloned_centralized_form_state_dispatch.reduce_mut_callback_with(
      |retrieved_store, event: FocusEvent| {
        event.prevent_default();
        retrieved_store.state_one_two_input_entry_set = retrieved_store.state_one_input.is_some() &amp;&amp; retieved_store.state_two_input.is_some();
      }
  );

  */

  //* Continue here..

  //* Note below, that you could either use a 'BasicStore' or a 'PersistentStore' with hook 'use_store'
  let centralized_form_state = use_store::&lt;Persistent&lt;CentralizedFormState&gt;&gt;();

  //* Supply &quot;state_one_input&quot; of &quot;CentralizedFormState&quot; which is now a persistent storage
  let supply_state_one_input = centralized_form_state.dispatch().reduce_callback_with(
    |retrieved_store, event: Event| {
      let received_state_one_input_value = event.target().unwrap().unchecked_into::&lt;HtmlInputElement&gt;().value();
      retrieved_store.state_one_input = if received_state_two_input_value.is_empty() {
          None
      } else {
          Some(received_state_one_input_value)
      }; //* conditional-check plays the role of a verified &quot;received_state_one_input_value&quot;
    }
  );

  //* Supply &quot;state_two_input&quot; of &quot;CentralizedFormState&quot; which is now a persistent storage
  //* ..//* Note that there is no need to clone &quot;centralized_form_state&quot;. You may as well not implement 'Clone' for &quot;CentralizedFormState&quot;
  let supply_state_two_input = centralized_form_state.dispatch().reduce_callback_with(
    |retrieved_store, event: Event| {
      let received_state_two_input_value = event.target().unwrap().unchecked_into::&lt;HtmlInputElement&gt;().value();
      retrieved_store.state_two_inut = if received_state_two_input_value.is_empty() {
        None
      } else {
        Some(received_state_two_input_value)
      }
    }
  );

  //* Create a Callback for the 'onsubmit' attribute of the whole form which would then trigger component &quot;SampleStoreSummaryComponent&quot;
  let onsubmit_response = cloned_centralized_form_state_dispatch.reduce_mut_callback_with(
      |retrieved_store, event: FocusEvent| {
        event.prevent_default();
        retrieved_store.state_one_two_input_entry_set = retrieved_store.state_one_input.is_some() &amp;&amp; retieved_store.state_two_input.is_some();
      }
  );

  html! {
    &lt;form onsubmit_response&gt;
      &lt;h4&gt;{&quot;Form data released below&quot;}&lt;/h4&gt;

      &lt;div&gt;
        &lt;div&gt;
          &lt;label for=&quot;state-one-input&quot;&gt;{&quot;StateOneInput&quot;}&lt;/label&gt;
        &lt;/div&gt;
        &lt;div&gt;
          {
            // You must assign the 'onchange' attribute of this input in the case to &quot;supply_state_one_input&quot; so it
            // ..can supply it the input received
          }
          &lt;input type=&quot;text&quot; id=&quot;state-one-input&quot; onchange={supply_state_one_input} placeholder=&quot;StateOneInput&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;div&gt;
          &lt;label for=&quot;state-two-input&quot;&gt;{&quot;StateTwoInput&quot;}&lt;/label&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;input type=&quot;password&quot; id=&quot;state-two-input&quot; onchange={supply_state_two_input} placeholder=&quot;StateTwoInput&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;button&gt;{&quot;ReleaseFormData&quot;}&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/components/sample_store_summary_component'</pre>
<pre><code class="language-rust">//* Another important file for this demo
//* The entire file is important
//* Important. Take Note!!!

use yew::prelude::*;
use yewdux::prelude::*;

//* Use 'yewdux_functional::use_store'
use yewdux::functional::use_store;

use crate::stores::sample_store::CentralizedFormState;

#[function_component(SampleStoreSummaryComponent)]
pub fn sample_store_summary_component() -&gt; Html {

  /*
  // * This code below has been re-written further down outside the block-comment

  // Since there is no plan to pass data to a centralized state/store, dispatch is not needed :)
  let (retrieved_store, _) = use_store::&lt;CentralizedFormState&gt;();

  let retrieved_state_one_input = format!(
    &quot;State one input is: {}&quot;,
    retrieved_store.state_one_input.as_deref().unwrap_or_default()
  );

  let retrieved_state_two_input = format!(
    &quot;State two input is: {}&quot;,
    retrieved_store.state_two_input.as_deref().unwrap_or_default()
  );

  let retrieved_state_one_and_two_input_entry_set = format!(
    &quot;State one and two input entry set true/false&quot;: {:?},
    retrieved_store.state_one_and_two_input_entry_set.as_deref().unwrap_or_default()
  );

  */

  //* Continue here

  let retrieved_store = use_store::&lt;PersistentStore&lt;YewduxStore&gt;&gt;();

  let retrieved_state_one_input = retrieved_store.state().map(
    |state| state.state_one_input.clone()
  ).unwrap_or_default();

  let retreived_state_two_input = retrieved_store.state().map(
    |state| state.state_two_input.clone()
  ).unwrap_or_default();

  let retrieved_state_one_and_two_input_entry_set = retrieved_store.state().map(
    |state| state.state_one_and_two_input_entry_set.clone()
  );

  html! {
    &lt;div&gt;

        {
          // The code below has been rewritten further down
        }
        &lt;h3&gt;{&quot;CentralizedFormState Data Summary&quot;}&lt;/h3&gt;
        &lt;div&gt;{retrieved_state_one_input}&lt;/div&gt;
        &lt;div&gt;{retrieved_state_two_input}&lt;/div&gt;
        &lt;div&gt;{retrieved_state_one_and_two_input_entry_set}&lt;/div&gt;

        {
          //* Time to showcase a summary of a centralized state store called &quot;CentralizedFormState&quot;
        }
        &lt;h3&gt;{&quot;CentralizedFormState Data Summary&quot;}&lt;/h3&gt;
        &lt;div&gt;{format!(&quot;State one input is: &quot;, retrieved_state_one_input)}&lt;/div&gt;
        &lt;div&gt;{format!(&quot;State two input is:, retrieved_state_two_input&quot;)}&lt;/div&gt;
        &lt;div&gt;{format!(&quot;State one and two input entry set true/false:&quot;, retrieved_state_one_and_two_input_entry_set)}&lt;/div&gt;

      &lt;/div&gt;
  }
}
</code></pre>
<pre>INSIDE 'yew_project_name/src/lib.rs'</pre>
<pre><code class="language-rust">//* expose sibling DIR 'stores'
mod stores; // DIR
mod components; // DIR

use yew::prelude::*;

//* This component is not needed anymore
use crate::components::sample_store_one_user_component::SampleStoreOneUserComponent;

//* Use &quot;SampleStoreUserComponent&quot;
use crate::components::sample_store_user_component::SampleStoreUserComponent;
//* Also use &quot;SampleStoreSummaryComponent&quot;
use crate::components::sample_store_summary_component::SampleStoreSummaryComponent;

//* This component is not needed anymore
use crate::components::sample_store_one_button_component::SampleStoreOneButtonComponent;

pub struct App{}

impl Component for App {

  type Message = ();
  type Properties = ();

  fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
    Self{}
  }

  fn view(&amp;self, _ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
    html! {
      &lt;div&gt;

        &lt;h2&gt;{&quot;You are inside app, the beginning of this app&quot;}&lt;/h2&gt;

        &lt;div&gt;

          {
            //* Component not needed anymore
          }
          &lt;SampleStoreOneUserComponent /&gt;


          {
            //* Component not needed anymore
          }
          &lt;SampleStoreOneButtonComponent /&gt;

          {
            //* Time to use the relevant component(s) that interacts with a yewdux centralized state/store
          }
          &lt;SampleStoreUserComponent /&gt;
          &lt;SampleStoreSummaryComponent /&gt;

        &lt;/div&gt;

      &lt;/div&gt;
    }
  }

}
</code></pre>
<pre>INSIDE 'yew_project_name/src/main.rs'</pre>
<pre><code class="language-rust">use yew_project_name::App;

fn main() {
  yew::start_app::&lt;App&gt;();
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
